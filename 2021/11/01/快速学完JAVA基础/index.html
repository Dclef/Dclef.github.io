<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>快速学完JAVA基础 | 老猫的博客</title><meta name="keywords" content="javase"><meta name="author" content="老猫"><meta name="copyright" content="老猫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、注释​	单行注释 &#x2F;&#x2F; 快捷键  ctrl+&#x2F; ​	多行注释  多行注释不能嵌套 ​	文档注释 JavaDoc 1.标识符定义​	大驼峰命名 (类名) 例如SelectById ​	小驼峰 (方法名  变量) 例如 selectById ​	一般全小写的命名是数据库的命名 二、数据类型​	对所有的数据进行分类（都有默认值） 1.数字1.1 整数byte[-128,">
<meta property="og:type" content="article">
<meta property="og:title" content="快速学完JAVA基础">
<meta property="og:url" content="https://dclef.icu/2021/11/01/%E5%BF%AB%E9%80%9F%E5%AD%A6%E5%AE%8CJAVA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="老猫的博客">
<meta property="og:description" content="一、注释​	单行注释 &#x2F;&#x2F; 快捷键  ctrl+&#x2F; ​	多行注释  多行注释不能嵌套 ​	文档注释 JavaDoc 1.标识符定义​	大驼峰命名 (类名) 例如SelectById ​	小驼峰 (方法名  变量) 例如 selectById ​	一般全小写的命名是数据库的命名 二、数据类型​	对所有的数据进行分类（都有默认值） 1.数字1.1 整数byte[-128,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/java.jpg">
<meta property="article:published_time" content="2021-11-01T01:00:00.000Z">
<meta property="article:modified_time" content="2022-06-20T03:02:20.614Z">
<meta property="article:author" content="老猫">
<meta property="article:tag" content="javase">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/java.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dclef/CDN/img/favicon.jpg"><link rel="canonical" href="https://dclef.icu/2021/11/01/%E5%BF%AB%E9%80%9F%E5%AD%A6%E5%AE%8CJAVA%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 老猫","link":"链接: ","source":"来源: 老猫的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '快速学完JAVA基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-20 11:02:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="老猫的博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/dclef/CDN/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">老猫的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">快速学完JAVA基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-01T01:00:00.000Z" title="发表于 2021-11-01 09:00:00">2021-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-20T03:02:20.614Z" title="更新于 2022-06-20 11:02:20">2022-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/javase/">javase</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="快速学完JAVA基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h2><p>​	单行注释 &#x2F;&#x2F; 快捷键  ctrl+&#x2F;</p>
<p>​	多行注释  多行注释不能嵌套</p>
<p>​	文档注释 JavaDoc</p>
<h3 id="1-标识符定义"><a href="#1-标识符定义" class="headerlink" title="1.标识符定义"></a>1.标识符定义</h3><p>​	大驼峰命名 (类名) 例如SelectById</p>
<p>​	小驼峰 (方法名  变量) 例如 selectById</p>
<p>​	一般全小写的命名是数据库的命名</p>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>​	对所有的数据进行分类（都有默认值）</p>
<h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1.数字"></a>1.数字</h3><h4 id="1-1-整数"><a href="#1-1-整数" class="headerlink" title="1.1 整数"></a>1.1 整数</h4><p>byte[-128,127] short int long —–0</p>
<h4 id="1-2-小数"><a href="#1-2-小数" class="headerlink" title="1.2 小数"></a>1.2 小数</h4><p>float[单精度浮点数] double[双精度浮点数] —-0.0</p>
<h4 id="1-3-字符"><a href="#1-3-字符" class="headerlink" title="1.3 字符"></a>1.3 字符</h4><p>char 单子字符或汉字 —空</p>
<p>‘A’ ‘a’ ‘好’ ‘牛牛’ ‘鸀’</p>
<h4 id="1-4-布尔型"><a href="#1-4-布尔型" class="headerlink" title="1.4 布尔型"></a>1.4 布尔型</h4><p>boolean 只有两个取值 —–false</p>
<p>true false</p>
<h4 id="1-5-String-字符串"><a href="#1-5-String-字符串" class="headerlink" title="1.5 String(字符串)"></a>1.5 String(字符串)</h4><p>“sadasdasd撒大苏打飒飒大”</p>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型:"></a>2.引用数据类型:</h3><p>默认值都是 null</p>
<p>常量: 一个固定不变的值</p>
<h4 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h4><p>语法一: 先定义 后赋值</p>
<p>语法二: 定义同时赋值</p>
<p>语法三: 同时定义多个变量</p>
<h3 id="3-变量的分类"><a href="#3-变量的分类" class="headerlink" title="3. 变量的分类"></a>3. 变量的分类</h3><h4 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h4><p>1.定义的位置类里面,方法的外面</p>
<p>2.全局都可以使用</p>
<p>3.不赋值也是可以使用的 有默认值</p>
<h4 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h4><p>1.定义在方法内部或者代码块里面</p>
<p>2.只能在当前的方法 或者代码块的内部使用</p>
<p>3.必须先赋值后使用</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>局部变量可以和成员重名，一般不推荐这么写。</p>
<p>在使用的时候 优先使用局部变量，其次才使用成员变量</p>
<h2 id="三、数据的类型转换"><a href="#三、数据的类型转换" class="headerlink" title="三、数据的类型转换"></a>三、数据的类型转换</h2><p>​	数据类型直接的相互转换</p>
<h3 id="1-自动转换"><a href="#1-自动转换" class="headerlink" title="1.自动转换"></a>1.自动转换</h3><p>多个不同类型的数据 进行数学运算的时候 进行自动提升</p>
<h3 id="2-强制转换"><a href="#2-强制转换" class="headerlink" title="2.强制转换"></a>2.强制转换</h3><p>把大的数据类型 使用一个小的类型来接收</p>
<p>语法：小数据类型 变量名 &#x3D; (小数据类型)大类型值&#x2F;大类型变量名;</p>
<p>注意：使用float或者Double精度会缺失需要用到BigDecimal方法</p>
<h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><h3 id="1-数学运算"><a href="#1-数学运算" class="headerlink" title="1.数学运算"></a>1.数学运算</h3><h4 id="1-1-加减乘除"><a href="#1-1-加减乘除" class="headerlink" title="1.1 加减乘除"></a>1.1 加减乘除</h4><p>+的功能 除了数学运算，可以拼接字符串</p>
<p>自增 自减 对于一个变量的操作</p>
<p>++ 在前 :先自增 再使用值（使用的是自增以后的值）</p>
<p>++ 在后:先使用值 再自增（使用的是自增之前的值）</p>
<h4 id="1-2-赋值运算"><a href="#1-2-赋值运算" class="headerlink" title="1.2 赋值运算"></a>1.2 赋值运算</h4><p>+&#x3D;  -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</p>
<p>使用的场景，把运算完成以后的结果赋值给本身</p>
<h4 id="1-3-比较运算"><a href="#1-3-比较运算" class="headerlink" title="1.3 比较运算"></a>1.3 比较运算</h4><p>&lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;    instanceof</p>
<p>instanceof：判断一个对象，或者实例 常量是否属于一个类型</p>
<h4 id="1-4-三目运算"><a href="#1-4-三目运算" class="headerlink" title="1.4 三目运算"></a>1.4 三目运算</h4><p>语法： x ? y : z;&#x2F;&#x2F; 表示如果x为true，执行y，x为false则执行z。</p>
<p>x：比较运算的结果  boolean类型的变量</p>
<h2 id="五、位运算"><a href="#五、位运算" class="headerlink" title="五、位运算"></a>五、位运算</h2><p>开发很少用，效率高，可读性差</p>
<h3 id="1-逻辑运算"><a href="#1-逻辑运算" class="headerlink" title="1.逻辑运算"></a>1.逻辑运算</h3><p>概念，综合多个比较的结果得出一个统一的概念</p>
<p>&amp;——并且</p>
<p>|——或者</p>
<p>!——取反</p>
<p>具有短路效果,可能效率要高一些</p>
<p>&amp;&amp; 和  &amp;最终的结果是一致</p>
<p>|| 和 |最终的结果是一致</p>
<h2 id="六、选择结构"><a href="#六、选择结构" class="headerlink" title="六、选择结构"></a>六、选择结构</h2><p>改变代码的执行流程</p>
<h3 id="1-if-条件语句"><a href="#1-if-条件语句" class="headerlink" title="1.if 条件语句"></a>1.if 条件语句</h3><h4 id="1-1-语法一"><a href="#1-1-语法一" class="headerlink" title="1.1 语法一"></a>1.1 语法一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(①判断结构)&#123;</span><br><span class="line"></span><br><span class="line">②//功能语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 ①最终结果为true 就去执行 ②的功能语句</p>
<p>如果 ①最终结果为false 就不执行 ②的功能语句</p>
<h4 id="1-2-语法二：互斥"><a href="#1-2-语法二：互斥" class="headerlink" title="1.2 语法二：互斥"></a>1.2 语法二：互斥</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(①判断结构)&#123;</span><br><span class="line"></span><br><span class="line">②//功能语句</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">③//功能语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 ①最终结果为true 就去执行 ②的功能语句，否则就去执行③功能语句</p>
<h4 id="1-3-语法三：多条件判断"><a href="#1-3-语法三：多条件判断" class="headerlink" title="1.3 语法三：多条件判断"></a>1.3 语法三：多条件判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if(①判断结构)&#123;</span><br><span class="line"></span><br><span class="line">②//功能语句</span><br><span class="line"></span><br><span class="line">&#125;else if(③判断结构)&#123;</span><br><span class="line"></span><br><span class="line">④//功能语句</span><br><span class="line"></span><br><span class="line">&#125;else if(⑤判断结构)&#123;</span><br><span class="line"></span><br><span class="line">⑥//功能语句</span><br><span class="line"></span><br><span class="line">&#125;else if(⑦判断结构)&#123;</span><br><span class="line"></span><br><span class="line">⑧//功能语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-switch-循环语句"><a href="#2-switch-循环语句" class="headerlink" title="2.switch 循环语句"></a>2.switch 循环语句</h3><p>使用场景：	一般用于有几种固定的取值情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">switch(变量)&#123;</span><br><span class="line"></span><br><span class="line">case 值1:</span><br><span class="line"></span><br><span class="line">功能语句1</span><br><span class="line"></span><br><span class="line">功能语句2...</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case 值2:</span><br><span class="line"></span><br><span class="line">功能语句1</span><br><span class="line"></span><br><span class="line">功能语句2...</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case 值3:</span><br><span class="line"></span><br><span class="line">功能语句1</span><br><span class="line"></span><br><span class="line">功能语句2...</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default语句</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-default"><a href="#2-1-default" class="headerlink" title="2.1 default"></a>2.1 default</h4><p>相当于条件语句中else，所有的case匹配不上执行</p>
<h4 id="2-2-break"><a href="#2-2-break" class="headerlink" title="2.2 break"></a>2.2 break</h4><p>特点结束当前的匹配功能语句。</p>
<h3 id="3-while循环语句"><a href="#3-while循环语句" class="headerlink" title="3.while循环语句"></a>3.while循环语句</h3><p>特点结束当前的匹配功能语句。</p>
<p>循环结构：重复的去执行一段代码</p>
<p>床–食堂–游戏</p>
<p>家–旅游–洗脚–公司</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">while(①判断语句)&#123;</span><br><span class="line"></span><br><span class="line">②//功能代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">①--true--②</span><br><span class="line"></span><br><span class="line">①--true--②</span><br><span class="line"></span><br><span class="line">①--true--②</span><br><span class="line"></span><br><span class="line">①--false 停止循环</span><br></pre></td></tr></table></figure>

<h3 id="4-dowhile循环语句"><a href="#4-dowhile循环语句" class="headerlink" title="4.dowhile循环语句"></a>4.dowhile循环语句</h3><p>基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">3.循环体（重复干的事）</span><br><span class="line"></span><br><span class="line">4.循环控制（根据条件判断是否要写）</span><br><span class="line"></span><br><span class="line">&#125; while (2.条件判断);// 注意分号</span><br></pre></td></tr></table></figure>

<p>第1次：1. 初始化条件语句 &#x3D;&gt; 3. 循环体 &#x3D;&gt; 4. 循环控制语句</p>
<p>第2次：2.条件判断语句 &#x3D;&gt; 3. 循环体 &#x3D;&gt; 4. 循环控制语句</p>
<p>第3次：2.条件判断语句 &#x3D;&gt; 3. 循环体 &#x3D;&gt; 4. 循环控制语句</p>
<h3 id="5-For循环"><a href="#5-For循环" class="headerlink" title="5.For循环"></a>5.For循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(①初始化条件语句; ②条件判断语句; ③循环后语句) &#123;</span><br><span class="line"></span><br><span class="line">④循环体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次循环： ①—②–true–④—③</p>
<p>第二次循环： ②–true–④—③</p>
<p>第三次循环： ②–true–④—③</p>
<p>第四次循环： ②–true–④—③</p>
<p>…</p>
<p>第n次循环： ②–false  —终止循环</p>
<h3 id="6-循环控制语句"><a href="#6-循环控制语句" class="headerlink" title="6.循环控制语句"></a>6.循环控制语句</h3><p>break: 表示结束当前层循环</p>
<p>continue:跳过本次循环</p>
<p>return：结束当前方法</p>
<h2 id="七、学习数组的标准"><a href="#七、学习数组的标准" class="headerlink" title="七、学习数组的标准"></a>七、学习数组的标准</h2><h3 id="1-如何定义一个数组-语法"><a href="#1-如何定义一个数组-语法" class="headerlink" title="1.如何定义一个数组(语法)"></a>1.如何定义一个数组(语法)</h3><h4 id="1-1-语法一-1"><a href="#1-1-语法一-1" class="headerlink" title="1.1 语法一"></a>1.1 语法一</h4><p>定义一个空数组（动态创建）</p>
<p>数据类型[] 名字&#x3D;new 数据类型[长度];</p>
<p>定义一个指定长度的空数组</p>
<h4 id="1-2-语法二"><a href="#1-2-语法二" class="headerlink" title="1.2 语法二"></a>1.2 语法二</h4><p>定义一个数组并赋值（静态）</p>
<p>数据类型[] 名字&#x3D;{值1，值2，值3，值4….}</p>
<h3 id="2-数组的取值与赋值"><a href="#2-数组的取值与赋值" class="headerlink" title="2.数组的取值与赋值"></a>2.数组的取值与赋值</h3><h4 id="2-1-赋值的语法"><a href="#2-1-赋值的语法" class="headerlink" title="2.1 赋值的语法"></a>2.1 赋值的语法</h4><p>数组名[索引位置]&#x3D;值;</p>
<h4 id="2-2-取值的语法"><a href="#2-2-取值的语法" class="headerlink" title="2.2 取值的语法"></a>2.2 取值的语法</h4><p>数组名[索引位置]</p>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>1.取值与赋值不能超出索引范围</p>
<p>2.数组一旦定义长度不能更改</p>
<p>3.数组的遍历(把数组里面的每一个数据读取出来)</p>
<h2 id="八、方法"><a href="#八、方法" class="headerlink" title="八、方法"></a>八、方法</h2><p>和主方法差不多 ,主方法main,有特殊性程序运行的唯一入口</p>
<p>其他的方法，普通方法</p>
<p>方法：就是功能的封装</p>
<h3 id="1-方法如何定义"><a href="#1-方法如何定义" class="headerlink" title="1.方法如何定义"></a>1.方法如何定义</h3><p>语法：</p>
<p>[修饰符] 返回值类型 方法名([形参1,形参2,..]){</p>
<p>&#x2F;&#x2F;方法体，这个方法的功能逻辑代码</p>
<p>}</p>
<p>void：返回值类型之一，没有返回值[占位符，为了满足语法需要]</p>
<h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2.方法调用"></a>2.方法调用</h3><p>程序只会执行main方法里面的内容</p>
<p>只能在main里面去调用普通方法</p>
<h4 id="2-1-方法名"><a href="#2-1-方法名" class="headerlink" title="2.1  方法名()"></a>2.1  方法名()</h4><p>   调用者和被调用者，必须在同一个类里面，两者要么都有static修饰，要么都没有static修饰</p>
<h4 id="2-2-类名-方法名"><a href="#2-2-类名-方法名" class="headerlink" title="2.2 类名.方法名()"></a>2.2 类名.方法名()</h4><p>被调用的方法有static修饰   类名：被调用方法所在类的类名【必须掌握，用的非常多】</p>
<h4 id="2-3-对象名-方法名"><a href="#2-3-对象名-方法名" class="headerlink" title="2.3 对象名.方法名()"></a>2.3 对象名.方法名()</h4><p> 被调用的方法没有static修饰【暂时不管】【必须掌握，用的非常多】</p>
<h3 id="程序运行的唯一入口"><a href="#程序运行的唯一入口" class="headerlink" title="程序运行的唯一入口"></a>程序运行的唯一入口</h3><p>​    	  1.main 执行的顺序 还是从上到下依次执行，遇到调用方法的时    候，把方法内部的逻辑全部执行完成以后，再继续往下执行<br>        2.方法的每一次调用都是完全独立的</p>
<h3 id="3-形参"><a href="#3-形参" class="headerlink" title="3.形参"></a>3.形参</h3><p>形式参数，注重只是传出的参数类型,方法在设计的时候不确定的值 （由用户在调用的时候才传入的值）</p>
<p>方法名(数据类型 变量名,数据类型 变量名,….)<br>*</p>
<h3 id="4-返回值类型"><a href="#4-返回值类型" class="headerlink" title="4.返回值类型"></a>4.返回值类型</h3><h4 id="4-1-void"><a href="#4-1-void" class="headerlink" title="4.1 void"></a>4.1 void</h4><p>​			没有返回值，void只是占位满足语法需求</p>
<h4 id="4-2数据类型（学习过的所有数据类型）："><a href="#4-2数据类型（学习过的所有数据类型）：" class="headerlink" title="4.2数据类型（学习过的所有数据类型）："></a>4.2数据类型（学习过的所有数据类型）：</h4><p>​			方法执行结束以后 返回一个指定类型的 数据</p>
<p>return 返回值;  返回数据的语法</p>
<p>把方法内部的执行结果返回给方法的调用者</p>
<h3 id="5-调用者对于方法的返回值有哪些处理方式？"><a href="#5-调用者对于方法的返回值有哪些处理方式？" class="headerlink" title="5.调用者对于方法的返回值有哪些处理方式？"></a>5.调用者对于方法的返回值有哪些处理方式？</h3><h4 id="5-1-直接打印"><a href="#5-1-直接打印" class="headerlink" title="5.1   直接打印"></a>5.1   直接打印</h4><h4 id="5-2-使用变量接收"><a href="#5-2-使用变量接收" class="headerlink" title="5.2  使用变量接收"></a>5.2  使用变量接收</h4><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>把同一类的方法，一般名字都保持一直。</p>
<p>Overload[重载] – Override[覆写]</p>
<p>方法名一致，形参列表不同【个数，类型，类型顺序】</p>
<h2 id="九、数组的存储模型"><a href="#九、数组的存储模型" class="headerlink" title="九、数组的存储模型"></a>九、数组的存储模型</h2><h3 id="1-1-栽"><a href="#1-1-栽" class="headerlink" title="1.1 栽"></a>1.1 栽</h3><p>​					存储的变量名 基本数据类型的值</p>
<h3 id="1-2-堆"><a href="#1-2-堆" class="headerlink" title="1.2 堆"></a>1.2 堆</h3><p>​				    引用数据类型的值</p>
<h2 id="十、方法调用的时候"><a href="#十、方法调用的时候" class="headerlink" title="十、方法调用的时候"></a>十、方法调用的时候</h2><p>​		基本数据类型传递的值得本身，引用数据类型传递的是地址的引用</p>
<h2 id="十一、可变参数"><a href="#十一、可变参数" class="headerlink" title="十一、可变参数"></a>十一、可变参数</h2><p>​		语法在定义方法的时候 可以使用数据类型</p>
<p>​		可变参数的本质还是数组</p>
<p>​		注意：在定义方法的时候 只能有一个可变参数，并且放在方法形参的末尾</p>
<h2 id="十二、for—each-增强for循环"><a href="#十二、for—each-增强for循环" class="headerlink" title="十二、for—each  增强for循环"></a>十二、for—each  增强for循环</h2><p>本质还是for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(数据类型 变量名 :数据源)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量名：就是循环以后数组里面的每一个值</p>
<p>数据类型：数组里面装的是什么类型</p>
<p>特点：foreach 没有下标</p>
<p>以后在使用的过程中，什么时候使用for循环 什么时候使用for–each</p>
<p>如果要用到索引，必须要使用普通for循环</p>
<h2 id="十三、javadoc"><a href="#十三、javadoc" class="headerlink" title="十三、javadoc"></a>十三、javadoc</h2><p>System</p>
<p>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>将指定源数组中的数据从指定位置复制到目标数组的指定位置。</p>
<p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目的地数据中的起始位置。<br>length - 要复制的数组元素的数量。</p>
<h2 id="十四、构造方法"><a href="#十四、构造方法" class="headerlink" title="十四、构造方法"></a>十四、构造方法</h2><h3 id="1-什么是构造方法？"><a href="#1-什么是构造方法？" class="headerlink" title="1.什么是构造方法？"></a>1.什么是构造方法？</h3><p>构造方法主要是用来创建对象</p>
<p>构造方法的语法</p>
<p>要求：没有返回值类型，方法名和类名保持一致（包括大小写）</p>
<p>[修饰符] 类名([形参]){<br>*</p>
<p>}</p>
<h3 id="1-2构造方法的作用"><a href="#1-2构造方法的作用" class="headerlink" title="1.2构造方法的作用"></a>1.2构造方法的作用</h3><p>1.主要使用来创建对象的,没有可用的构造方法 就不能创建对象</p>
<p>2.创建对象的时候赋值</p>
<h3 id="1-3构造方法的注意点"><a href="#1-3构造方法的注意点" class="headerlink" title="1.3构造方法的注意点"></a>1.3构造方法的注意点</h3><p>1.每一个类都有一个隐式公共无参数的构造方法–学习了反射就能够证明</p>
<p>2.如果类里面显示的写了构造方法，隐式的无参数的构造方法就不存在了—–如果要显示的添加构造方法，一般建议把无参数的构造方法也加上</p>
<h3 id="1-4问构造方法和方法有什么区别？"><a href="#1-4问构造方法和方法有什么区别？" class="headerlink" title="1.4问构造方法和方法有什么区别？"></a>1.4问构造方法和方法有什么区别？</h3><p>构造方法               方法</p>
<p>1.返回值类型             无                  有</p>
<p>2.方法的名字           必须和类名一致        无特殊要求</p>
<p>3.static              不能修饰            可以修饰</p>
<p>4.调用方式               new              类名.&#x2F;对象名.</p>
<p>5.功能                 创建对象            普通工具</p>
<p>public Account(){} 是</p>
<p>public void Account(){} 不是【不建议这么去定义普通方法】</p>
<h2 id="十五、匿名对象"><a href="#十五、匿名对象" class="headerlink" title="十五、匿名对象"></a>十五、匿名对象</h2><p>对象的生命周期:</p>
<p>开始—被创建的时候（new）</p>
<p>结束—被垃圾回收器回收的时候，失去引用的时候</p>
<p>对象的生命周期：</p>
<p>人的生命周期：</p>
<p>开始—出生</p>
<p>结束—死亡（心脏，脑死亡，失踪，被所有人遗忘的时候）</p>
<h2 id="十六、继承"><a href="#十六、继承" class="headerlink" title="十六、继承"></a>十六、继承</h2><p>public class 类名 extends 父类的类名{}</p>
<h3 id="1-可以继承哪些内容？"><a href="#1-可以继承哪些内容？" class="headerlink" title="1.可以继承哪些内容？"></a>1.可以继承哪些内容？</h3><p>属性</p>
<p>方法</p>
<h3 id="2-受哪些因数影响？"><a href="#2-受哪些因数影响？" class="headerlink" title="2. 受哪些因数影响？"></a>2. 受哪些因数影响？</h3><p> 非私有化的成员变量和方法</p>
<p> 构造方法不能被继承</p>
<h3 id="3-继承的特点"><a href="#3-继承的特点" class="headerlink" title="3. 继承的特点"></a>3. 继承的特点</h3><p>1.java里面3类只能单继承，一个类只能一个直接父类</p>
<p>2.java支持多层级继承</p>
<p>3.如果一类没有显示的去继承任何一个类，这个类继承于Object</p>
<p>Object:超类，所有类的直接或间接父类</p>
<h2 id="十七、方法覆写-Override"><a href="#十七、方法覆写-Override" class="headerlink" title="十七、方法覆写-Override"></a>十七、方法覆写-Override</h2><h3 id="1-什么情况下需要方法的覆写？"><a href="#1-什么情况下需要方法的覆写？" class="headerlink" title="1. 什么情况下需要方法的覆写？"></a>1. 什么情况下需要方法的覆写？</h3><p>当父类方法的功能无法满足子类的需要，需要方法覆写	</p>
<h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><p>1.子类方法的权限修饰符，大于等于父类权限修饰符</p>
<p>2.子类方法的返回值类型必须要小于等于父类方法的返回值类型</p>
<p>3.方法.名一致</p>
<p>4.形参类型一致</p>
<p>方法名+形参列表&#x3D;方法签名</p>
<h4 id="2-1-一般情况下"><a href="#2-1-一般情况下" class="headerlink" title="2.1 一般情况下"></a>2.1 一般情况下</h4><p>方法的覆写都是把父类的方法直接copy过来，更改里面的方法体就ok</p>
<h4 id="2-2-方法调用的整体大纲"><a href="#2-2-方法调用的整体大纲" class="headerlink" title="2.2 方法调用的整体大纲"></a>2.2 方法调用的整体大纲</h4><p>一般来讲，在调用方法的时候有限找子类方法，如果子类没有，就去找父类的方法 </p>
<h2 id="十八、super"><a href="#十八、super" class="headerlink" title="十八、super"></a>十八、super</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>1.可以在子类构造方法里面调用父类的构造方法，必须写在第一行</p>
<p>2.当子类里面的方法或者属性和父类的方法或者属性重名的时候，区分二义性</p>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><p>子类的构造方法里面，默认都是在调用父类的无参数构造方法</p>
<h3 id="3-super和this的区别"><a href="#3-super和this的区别" class="headerlink" title="3. super和this的区别"></a>3. super和this的区别</h3><p>this:就是指当期对象—-this就是对象</p>
<p>super:指的是父类的成员(属性，方法)，但是不是父类对象，不持有父类对象的地址引用</p>
<h2 id="十九、抽象类"><a href="#十九、抽象类" class="headerlink" title="十九、抽象类"></a>十九、抽象类</h2><p>抽象类定义的语法</p>
<p>把由abstract 修饰类 叫做抽象类</p>
<h3 id="1-1-抽象类里面有哪些成员"><a href="#1-1-抽象类里面有哪些成员" class="headerlink" title="1.1 抽象类里面有哪些成员"></a>1.1 抽象类里面有哪些成员</h3><p>普通方法</p>
<p>抽象方法</p>
<p>构造方法:有构造方法，但是不能创建对象，由protected修饰的，主要是用于继承的时候子类调用;</p>
<p>成员变量</p>
<h3 id="1-2-抽象方法"><a href="#1-2-抽象方法" class="headerlink" title="1.2 抽象方法"></a>1.2 抽象方法</h3><p>[父类定义了一些规范]</p>
<p>由abstract 修饰的方法叫做抽象方法，方法的没有方法体</p>
<p>子类继承父类以后，必须要去覆写父类的所有抽象方法</p>
<p>只能出现在抽象类中</p>
<p> abstact 抽象的 出现在修饰符与 返回值之间</p>
<p> 抽象类中可以有变量 方法  抽象方法（可有可无）</p>
<h3 id="1-3-目前这个知识点"><a href="#1-3-目前这个知识点" class="headerlink" title="1.3 目前这个知识点"></a>1.3 目前这个知识点</h3><p>1.必须知道抽象类的定义语法</p>
<p>2.抽象里面可以定义那些成员</p>
<p>3.抽象方法不能创建对象</p>
<p>4.子类必须要去覆写父类的所有抽象方法</p>
<h2 id="二十、接口"><a href="#二十、接口" class="headerlink" title="二十、接口"></a>二十、接口</h2><h3 id="1-接口的作用"><a href="#1-接口的作用" class="headerlink" title="1. 接口的作用"></a>1. 接口的作用</h3><p>1.用来定义规范</p>
<p>2.解耦</p>
<h3 id="2-后面这些功能体现"><a href="#2-后面这些功能体现" class="headerlink" title="2.后面这些功能体现"></a>2.后面这些功能体现</h3><p>1.jdbc 定义的规范</p>
<p>2.servlet 也是一套接口  定义了规范</p>
<h3 id="3-接口的语法"><a href="#3-接口的语法" class="headerlink" title="3.接口的语法"></a>3.接口的语法</h3><p>接口和类 是同一个级别，但是完全不同的两种类型</p>
<p>interface 接口名字{</p>
<p>}</p>
<p>接口的里面可以有哪些成员：</p>
<p>成员变量</p>
<p>抽象方法【百分之90接口只是提供抽象方法】</p>
<h3 id="4-在jdk的1-8以后新增很多新特性"><a href="#4-在jdk的1-8以后新增很多新特性" class="headerlink" title="4. 在jdk的1.8以后新增很多新特性"></a>4. 在jdk的1.8以后新增很多新特性</h3><p>1.可以有静态方法   -由static修饰的</p>
<p>2.可以有默认方法   -由default修饰的</p>
<p>实现的语法：</p>
<p>class 类名 implements 接口名{</p>
<p>&#x2F;&#x2F;必须要去覆写所有接口的抽象方法</p>
<p>}</p>
<h2 id="二十一、覆写的应用"><a href="#二十一、覆写的应用" class="headerlink" title="二十一、覆写的应用"></a>二十一、覆写的应用</h2><p>父类方法功能无法满足子类需求的时候 ，去覆写父类方法</p>
<h3 id="方法覆写的调用规则"><a href="#方法覆写的调用规则" class="headerlink" title="方法覆写的调用规则"></a>方法覆写的调用规则</h3><p>优先找子类的方法，如果子类没有，再找父类的方法</p>
<p>当继承的父类的某个方法，不满足现有的需求，那么可以在子类中进行重写</p>
<p>方法的重写：将父类的方法直接继承到子类中，主要改写，该方法体的内容</p>
<p>方法重写的条件：必须在继承关系中去实现</p>
<p>方法重写：修饰符（子类中修饰符权限更大） 返回值为void是，父类和子类中的返回值类型一致 如果父类中的返回值不为void类型 </p>
<p>​         那么子类中的返回值应该小于等于父类中的返回值为八大类型，那么子类的返回值应该与父类的返回值一致</p>
<p>自定义类型比较：进行排序使用</p>
<p>自定义类型比较的实施：在自定义类中重写equals方法</p>
<h2 id="二十二、Object"><a href="#二十二、Object" class="headerlink" title="二十二、Object"></a>二十二、Object</h2><p>boolean equals(Object obj)  指示一些其他对象是否等于此。[非常重要]</p>
<p>protected void finalize()  当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。  –回收垃圾</p>
<h3 id="1-final-finally-finalize-区别？"><a href="#1-final-finally-finalize-区别？" class="headerlink" title="1. final finally finalize -区别？"></a>1. final finally finalize -区别？</h3><p>Class&lt;?&gt; getClass()  返回此 Object的运行时类。</p>
<p>int hashCode()  返回对象的哈希码值。  –对象存储的在内存里面的位置值</p>
<p>&#x3D;&#x3D; 是用来比较基本数据类型的值是否相等</p>
<p>如果用于引用数据类型的比较，比较的是两个对象的地址值</p>
<p>注意：特殊情况除外，例如String 以及八大基本数据类型对应的包装类除外</p>
<h3 id="2-讨论"><a href="#2-讨论" class="headerlink" title="2. 讨论"></a>2. 讨论</h3><p>比较两个对象，到底是应该比较两个对象的地址，还是比较两个对象的里面存储的数据？</p>
<p>例如 两张身份证长得一模一样    姓名 性别 出生年月 身份证号码  图片</p>
<p>在java领域里面 引用数据类型比较应该使用equals方法—Object[能够比较里面存储的数据]</p>
<p>注意：默认 equals方法底层还是 &#x3D;&#x3D; 在比较两个对象地址值是否相等，</p>
<p>覆写equals方法比较两个对象里面的值是否相等。</p>
<h3 id="3-思考：面试题"><a href="#3-思考：面试题" class="headerlink" title="3. 思考：面试题"></a>3. 思考：面试题</h3><p>说一说 &#x3D;&#x3D; 和 equals 的区别？</p>
<p>自己先尝试整理一个稍微专业一点的回答话术。</p>
<p>&#x3D;&#x3D; 用于比较基本数据类型的两个值是否相等，如果用于比较引用数据类型，比较的是两个对象地址值</p>
<p>equals:用于比较两个对象里面存储的数据是否相等，但是equals底层还是&#x3D;&#x3D;，所以我们在使用的时候要腹泻equals方法</p>
<h2 id="二十三、多态"><a href="#二十三、多态" class="headerlink" title="二十三、多态"></a>二十三、多态</h2><h3 id="1-例子"><a href="#1-例子" class="headerlink" title="1. 例子"></a>1. 例子</h3><p>一个人 是 人            Person p   &#x3D;  new Person()</p>
<p>一头猪 是 猪            Pig pig    &#x3D;    new Pig()</p>
<p>一个人 是 动物         Animal a    &#x3D;  new Pserson（）</p>
<p>一头猪 是 动物         Animal  a2 &#x3D; new Pig()</p>
<p>一个人 是 猪(错误)            Pig p &#x3D; new Person()</p>
<p>一头猪 是 人 (错误)           Person p &#x3D; new Pig()</p>
<h3 id="2-官方"><a href="#2-官方" class="headerlink" title="2. 官方"></a>2. 官方</h3><p>编译时类型和运行时类型不一致的情况叫做多态</p>
<h3 id="3-坊间"><a href="#3-坊间" class="headerlink" title="3. 坊间"></a>3. 坊间</h3><p>使用父类类型接收子类对象，或者使用接口 接收接口的实现类对象–多态</p>
<p>使用多态的时候，方法的调用的问题：</p>
<p>方法覆写以后，方法的调用顺序是不变的</p>
<h3 id="Super–父类相关"><a href="#Super–父类相关" class="headerlink" title="Super–父类相关"></a>Super–父类相关</h3><p>super用在子类中的–只有在子类中才会区别，到底是使用的父类的属性&#x2F;方法还是使用子类中的属性&#x2F;方法</p>
<p> super可以直接打印吗？</p>
<p>super代指的父类（没有持有父类的对象（没有创建））this可以直接打印，持有当前对象</p>
<p> Super():只能放在子类中的构造方法的第一行，子类创建对象的时候，先要调用父类的构造方法，是为了可以继承的相关属性和方法</p>
<h2 id="二十四、final"><a href="#二十四、final" class="headerlink" title="二十四、final"></a>二十四、final</h2><p>​		也是一个修饰符，翻译过来是最终的</p>
<p>成员变量  局部变量 构造方法 普通方法   内部类, 类</p>
<h3 id="1-可以修饰内容"><a href="#1-可以修饰内容" class="headerlink" title="1. 可以修饰内容"></a>1. 可以修饰内容</h3><p>类，成员变量 局部变量 普通方法  内部类</p>
<h3 id="2-被final修饰以后有什么效果"><a href="#2-被final修饰以后有什么效果" class="headerlink" title="2. 被final修饰以后有什么效果"></a>2. 被final修饰以后有什么效果</h3><p>类：final修饰的类不能被其他类继承              开发中有没有类不允许继承？ String-八大基本数据类型对应的包装类</p>
<p>成员变量：final修饰的成员变量不允许更改值</p>
<p>局部变量：一旦赋值就不能个更改</p>
<p>普通方法：final修饰的方法不能够被覆写</p>
<h2 id="二十五、static"><a href="#二十五、static" class="headerlink" title="二十五、static"></a>二十五、static</h2><p>成员变量：被所有对象所共享  应用场景：火车站卖票，对象之间应该共享的属性</p>
<p>方法：修饰方法的时候仅仅只是为了方便调用，使用类名就可以直接调用，一般工具类的方法适合定义为static修饰的方法     例如 Arrays</p>
<p>面向对象阶段：如果要操作非static的成员变量的时候，不考虑static</p>
<p>静态方法不能操作非静态的成员变量</p>
<h3 id="1-static：修饰的成员正确的使用方式"><a href="#1-static：修饰的成员正确的使用方式" class="headerlink" title="1. static：修饰的成员正确的使用方式"></a>1. static：修饰的成员正确的使用方式</h3><h3 id="1-1-修饰成员变量"><a href="#1-1-修饰成员变量" class="headerlink" title="1.1 修饰成员变量"></a>1.1 修饰成员变量</h3><p>类名.属性名</p>
<p>修饰的方法：</p>
<p>类名.方法名();</p>
<h3 id="1-2-方法的调用"><a href="#1-2-方法的调用" class="headerlink" title="1.2 方法的调用"></a>1.2 方法的调用</h3><p>1.方法名(); 在同一个类里面，要么都被static修饰，要么都没有被static修饰</p>
<p>2.类名.方法名(); 被修饰的方法被static修饰</p>
<p>3.对象.方法名(); 被调用的方法没有被static修饰</p>
<h3 id="2-static修饰的成员的称呼"><a href="#2-static修饰的成员的称呼" class="headerlink" title="2. static修饰的成员的称呼"></a>2. static修饰的成员的称呼</h3><table>
<thead>
<tr>
<th>类名</th>
<th align="center">位置</th>
<th align="center">是否有static</th>
<th align="left">生命周期开始</th>
<th align="left">生命周期结束</th>
</tr>
</thead>
<tbody><tr>
<td>类变量</td>
<td align="center">类中</td>
<td align="center">有</td>
<td align="left">类被加载的时候</td>
<td align="left">类被卸载的时候</td>
</tr>
<tr>
<td>实例变量</td>
<td align="center">类中</td>
<td align="center">无</td>
<td align="left">创建对象的时候</td>
<td align="left">对象失去引用</td>
</tr>
<tr>
<td>局部变量</td>
<td align="center">方法代码块中</td>
<td align="center">无</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="二十六、匿名内部类"><a href="#二十六、匿名内部类" class="headerlink" title="二十六、匿名内部类"></a>二十六、匿名内部类</h2><p>Usb这个接口不能new 创建对象</p>
<h3 id="1-正常的顺序"><a href="#1-正常的顺序" class="headerlink" title="1. 正常的顺序:"></a>1. 正常的顺序:</h3><p>1.新建一个类 实现Usb这个接口</p>
<p>2.创建实现类对象,并调用接口方法</p>
<h3 id="2-匿名内部类使用场景："><a href="#2-匿名内部类使用场景：" class="headerlink" title="2. 匿名内部类使用场景："></a>2. 匿名内部类使用场景：</h3><p>1.接口的里面的抽象方法并不多（1-3个）</p>
<p>2.对于接口的实现类对象不会重复使用（只是需要一个对象用一次）</p>
<p>3.不想再去多创建一个实现类文件</p>
<h2 id="二十七、代码块"><a href="#二十七、代码块" class="headerlink" title="二十七、代码块"></a>二十七、代码块</h2><p>由 { 代码 } 包裹起来的代码 叫做代码块</p>
<p>从代码块存放的位置来讲把代码块分为3类：</p>
<h3 id="1-构造代码块"><a href="#1-构造代码块" class="headerlink" title="1. 构造代码块"></a>1. 构造代码块</h3><p>写在类里面的代码块，叫做构造代码块,创建对象的时候执行【没啥用】</p>
<p>因为构造代码块编译以后里面的内容就会放到构造方法中，所以构造代码块随着对象的创建而去执行</p>
<h3 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2. 静态代码块"></a>2. 静态代码块</h3><p>放在类里面由static修饰的代码块【以后会使用】</p>
<p>随着类的加载而执行一次   应用场景</p>
<p>【加载配置文件，应为配置文件只是加载一次】</p>
<h3 id="3-局部代码块"><a href="#3-局部代码块" class="headerlink" title="3. 局部代码块"></a>3. 局部代码块</h3><p> 放在方法的内部，主要作用用于区分方法功能性【没啥用】</p>
<p>随着方法的执行而执行</p>
<h2 id="二十八、面对对象整体架构"><a href="#二十八、面对对象整体架构" class="headerlink" title="二十八、面对对象整体架构"></a>二十八、面对对象整体架构</h2><p><strong>面向过程关注过程每一个实现的步骤</strong></p>
<p>面向对象关注的结果把没有给步骤交给其他类和方法处理</p>
<p>面向对象编程：万物皆可对象将世间万物看不见的抽象成对象</p>
<p>对象：<strong>数据的集合，包含了属性和方法</strong></p>
<h3 id="核心内容：封装-继承-多态"><a href="#核心内容：封装-继承-多态" class="headerlink" title="核心内容：封装-继承-多态"></a>核心内容：封装-继承-多态</h3><h4 id="1-封装思想"><a href="#1-封装思想" class="headerlink" title="1. 封装思想"></a>1. 封装思想</h4><p>为了使成员变量更加安全和私密，给成员变量加上private进行私有化。</p>
<p>–先加上SetName GetName –pubilc</p>
<h4 id="2-继承思想"><a href="#2-继承思想" class="headerlink" title="2. 继承思想"></a>2. 继承思想</h4><h5 id="2-1-继承的好处"><a href="#2-1-继承的好处" class="headerlink" title="2.1 继承的好处"></a>2.1 继承的好处</h5><p>减少代码量&#x2F;减少重复的代码</p>
<h5 id="2-2-继承之后的效果"><a href="#2-2-继承之后的效果" class="headerlink" title="2.2 继承之后的效果"></a>2.2 继承之后的效果</h5><p>子类可以直接使用父类的属性&#x2F;方法 无需再定义</p>
<h5 id="2-3-继承的优点"><a href="#2-3-继承的优点" class="headerlink" title="2.3 继承的优点"></a>2.3 继承的优点</h5><p>如果父类中的属性&#x2F;方法，如果使用了private修饰，那么子类是无法继承的</p>
<p>子类无法同时继承多个类 但是继承支持多层继承</p>
<h4 id="3-多态思想"><a href="#3-多态思想" class="headerlink" title="3. 多态思想"></a>3. 多态思想</h4><p>创建了子类对象 使用父类来 接收 -这种场景称为多态</p>
<p>官方说法：编译时类型与运行时类型不一致的情况叫做多态</p>
<p>编译时类型：等号的左边，编译阶段编译器看成的类型</p>
<p> 运行时类型： 等号右边，运行阶段，对象真实的类型</p>
<h2 id="二十九、包装类"><a href="#二十九、包装类" class="headerlink" title="二十九、包装类"></a>二十九、包装类</h2><h3 id="1-什么是包装类"><a href="#1-什么是包装类" class="headerlink" title="1.什么是包装类"></a>1.什么是包装类</h3><p>答：就是针对8大基本数据类型，提供的类的表示形式<br> byte		Byte<br> short		Short<br> int			Integer<br> long		Long<br> float		Float<br> double		Double<br> char		Character<br> boolean		Boolean</p>
<p> 例如 上面的就是基本数据类型对应的包装类，Byte 描述的就是 [-128,127] 这一类事物</p>
<h3 id="2-为什么要提供包装类"><a href="#2-为什么要提供包装类" class="headerlink" title="2.为什么要提供包装类"></a>2.为什么要提供包装类</h3><p>答：基本数据类型 只能单纯的表示一个数字或者值，类除了可以表示一个值 还可以提供方法</p>
<p>例如 byte 只能表示 [-128,127]的数字，但是包装类除了可以表示 [-128,127]的数字 提供的有对应一些方法</p>
<h3 id="3-包装类和基本数据类型有哪些不同"><a href="#3-包装类和基本数据类型有哪些不同" class="headerlink" title="3.包装类和基本数据类型有哪些不同"></a>3.包装类和基本数据类型有哪些不同</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>基本数据类型 有各自默认值</p>
<p>包装类 默认值是 null</p>
<h4 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h4><p>基本数据类型 不能够去调用方法</p>
<p>引用数据类型可以调用方法</p>
<h2 id="三十、包装类装箱与拆箱"><a href="#三十、包装类装箱与拆箱" class="headerlink" title="三十、包装类装箱与拆箱"></a>三十、包装类装箱与拆箱</h2><p>装箱：把基本数据类型赋值给一个对应的包装类的过程</p>
<p>自动装箱拆箱只支持 基本数据类型和其对应的包装类</p>
<p>拆箱：把一个包装类的类型 赋值给一个对应的基本数据类型的过程</p>
<p>享元模式：设计思想和常量池有点类似 轻量级框架设计</p>
<p>享元模式：把[-128,127]之间所有的数组都缓存起来，方便节约内存重复使用</p>
<p>包装类：享元模式   提前缓存好</p>
<p>String：常量池  用的时候先去找，没找到再缓存</p>
<p>结论：比较两个包装类型的数字是否想的还是应该使用equals</p>
<h2 id="三十一、String"><a href="#三十一、String" class="headerlink" title="三十一、String"></a>三十一、String</h2><p>表示字符串的</p>
<p>“abc” 和  new String(“abc”)都是String的对象</p>
<p>构造方法：</p>
<p>String()  初始化新创建的 String对象，</p>
<p>使其表示空字符序列。  相当于  “”</p>
<h2 id="三十二、String-的常用方法"><a href="#三十二、String-的常用方法" class="headerlink" title="三十二、String 的常用方法"></a>三十二、String 的常用方法</h2><p>char charAt(int index)  返回 char指定索引处的值。</p>
<p>String concat(String str)  将指定的字符串连接到该字符串的末尾。</p>
<p>boolean endsWith(String suffix)  测试此字符串是否以指定的后缀结尾。</p>
<p>int indexOf(int ch)  返回指定字符第一次出现的字符串内的索引。</p>
<p>boolean isEmpty()  返回 true如果，且仅当 length()为 0 。</p>
<p>int length()  返回此字符串的长度。</p>
<p>String replace(CharSequence target, CharSequence replacement)</p>
<p>将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。</p>
<p>String[] split(String regex)  将此字符串分割为给定的 regular expression的匹配。</p>
<p>String substring(int beginIndex)  返回一个字符串，该字符串是此字符串的子字符串。</p>
<p>String substring(int beginIndex, int endIndex)  返回一个字符串，该字符串是此字符串的子字符串。</p>
<p>char[] toCharArray()  将此字符串转换为新的字符数组。</p>
<p>String toLowerCase()  将所有在此字符 String使用默认语言环境的规则，以小写。</p>
<p>String toUpperCase()  将所有在此字符 String使用默认语言环境的规则大写。</p>
<p>String trim()  返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。</p>
<h2 id="三十三、-x3D-x3D-和-equals区别？"><a href="#三十三、-x3D-x3D-和-equals区别？" class="headerlink" title="三十三、&#x3D;&#x3D; 和 equals区别？"></a>三十三、&#x3D;&#x3D; 和 equals区别？</h2><p>对于引用数据类型：</p>
<p>&#x3D;&#x3D; 比较的两个对象的地址值</p>
<p>equals 比较的是两个对象里面存储的数据</p>
<h2 id="三十六、String常量池"><a href="#三十六、String常量池" class="headerlink" title="三十六、String常量池"></a>三十六、String常量池</h2><p>按照对象的存储特点，每一个对象在堆里面的引用地址都不一致，如果使用&#x3D;&#x3D; 比较都应该是false</p>
<p>(1)当第一次使用String  str &#x3D; “A”; 的方式赋值，会将该字符串值【对象】放入到常量池<br>(2)当再次使用String  str &#x3D; “A”; 的方式会先检查常量池是否有”A”值，<br>①	如果存在直接引用<br>②	如果不存在，会创建”A”放入常量池<br>(3)字符串拼接<br>①	常量方式拼接，并直接使用赋值符号赋值，会检查常量池<br>②	变量方式拼接，不会检查常量池【注意】</p>
<p>结论：String的比较还是应该使用equals不能使用&#x3D;&#x3D;</p>
<h2 id="三十七、String-StringBuilder-StringBuffer-都是字符串"><a href="#三十七、String-StringBuilder-StringBuffer-都是字符串" class="headerlink" title="三十七、String StringBuilder StringBuffer 都是字符串"></a>三十七、String StringBuilder StringBuffer 都是字符串</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>StringBuffer(String str)  构造一个初始化为指定字符串内容的字符串缓冲区。</p>
<p>StringBuilder，StringBuffer</p>
<p>StringBuffer append(Object obj)  追加 Object参数的字符串表示。</p>
<p>【可以动态的拼接字符串】</p>
<p>使用场景：一般用于有大量的字符拼接的情况，例如生成 csv格式对账单{80-150w}</p>
<p>String 的拼接效率太低了</p>
<p>等到线程那一天学习：</p>
<p>StringBuffer:是线程安全的  效率稍低  使用单线程</p>
<p>StringBuilder:线程不安全的  效率最高 使用多线程</p>
<h2 id="三十八、Math"><a href="#三十八、Math" class="headerlink" title="三十八、Math"></a>三十八、Math</h2><h3 id="1-字段-PI"><a href="#1-字段-PI" class="headerlink" title="1. 字段  PI"></a>1. 字段  PI</h3><p>static double random()  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</p>
<p>方法都不怎么常用，在某些特定领域用的就非常多（小猿搜题）</p>
<p>BigInteger（基本不用-了解）</p>
<p>可以用来去表示比Long更大的数字</p>
<h3 id="2-BigDecimal【重点】"><a href="#2-BigDecimal【重点】" class="headerlink" title="2. BigDecimal【重点】"></a>2. BigDecimal【重点】</h3><p>|-可以用来去表示精确浮点数</p>
<p>（double和float都不能精确的表示一个小数）</p>
<h4 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法:"></a>2.1 构造方法:</h4><p>BigDecimal(String val)   将 BigDecimal 的字符串表示形式转换为 BigDecimal。</p>
<p>形参为什么不给一个double去表示一个精确的小数</p>
<p>数字常用的操作  + - * &#x2F; 都是通过方法来完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span>  <span class="comment">// 求和</span></span><br></pre></td></tr></table></figure>

<p>返回一个 BigDecimal，其值为 (this + augend)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor)</span>      <span class="comment">//除法</span></span><br></pre></td></tr></table></figure>

<p>返回一个 BigDecimal，其值为 (this &#x2F; divisor)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span>  <span class="comment">//乘法</span></span><br></pre></td></tr></table></figure>

<p>返回一个 BigDecimal，其值为 (this × multiplicand)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span>  <span class="comment">//减法</span></span><br></pre></td></tr></table></figure>

<p>返回一个 BigDecimal，其值为 (this - subtrahend)</p>
<h4 id="2-2-BigDecimal一般用于哪些行业和领域？"><a href="#2-2-BigDecimal一般用于哪些行业和领域？" class="headerlink" title="2.2 BigDecimal一般用于哪些行业和领域？"></a>2.2 BigDecimal一般用于哪些行业和领域？</h4><p>BigDecimal一般需要表示一些精确的小数的时候都需要使用它，涉及到钱相关的，建筑行业</p>
<p>关于数学数字处理 不是一味地四舍五入</p>
<p>数字的舍入方式：   银行卡的余额 一般是小数点后面 2位</p>
<p>金融领域里面：利息和手续费</p>
<p>利息 –例如312.359—312.35</p>
<p>手续费–例如0.231—-0.24</p>
<h2 id="三十九、java里面随机数获取方式"><a href="#三十九、java里面随机数获取方式" class="headerlink" title="三十九、java里面随机数获取方式"></a>三十九、java里面随机数获取方式</h2><h3 id="1-Math"><a href="#1-Math" class="headerlink" title="1. Math"></a>1. Math</h3><p>static double random()  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</p>
<h3 id="2-Random"><a href="#2-Random" class="headerlink" title="2. Random"></a>2. Random</h3><p>int nextInt()   返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。</p>
<p>生成一个 int 范围内的随机数</p>
<p>int nextInt(int n)  返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。<br>ThreadLocalRandom:—1.7版本</p>
<p>int nextInt(int origin, int bound)  返回指定原点（含）和指定边界（排除）之间的伪随机 int值。</p>
<p>生成 [origin,bound)</p>
<p>UUID:生成的是一个唯一不重复的随机数</p>
<p>static UUID randomUUID()  静态工厂检索一个类型4（伪随机生成）的UUID。</p>
<h2 id="四十、System"><a href="#四十、System" class="headerlink" title="四十、System"></a>四十、System</h2><p>static long currentTimeMillis()   返回以毫秒为单位的当前时间。</p>
<p>static void gc()  运行垃圾回收器。  java里面的垃圾回收器是自动回收</p>
<p>这个方法只能主动的催促运行垃圾回收器，但是不是立即运行</p>
<p>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p>
<h3 id="1-Runtime"><a href="#1-Runtime" class="headerlink" title="1. Runtime"></a>1. Runtime</h3><p>获取Runtime的对象</p>
<p>static Runtime getRuntime()  返回与当前 Java 应用程序相关的运行时对象。</p>
<p>方法</p>
<p>Process exec(String command)   在单独的进程中执行指定的字符串命令。 可以调用windows程序</p>
<p>void gc()   运行垃圾回收器。</p>
<h2 id="四十一、和时间相关的类"><a href="#四十一、和时间相关的类" class="headerlink" title="四十一、和时间相关的类"></a>四十一、和时间相关的类</h2><h3 id="1-java-util-Date-学习"><a href="#1-java-util-Date-学习" class="headerlink" title="1. java.util.Date[学习]"></a>1. java.util.Date[学习]</h3><h4 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h4><p>Date()  分配一个 Date对象，并初始化它，以便它代表它被分配的时间，测量到最近的毫秒。</p>
<p>Date(long date) 分配一个 Date对象，并将其初始化为表示自称为“时代”的标准基准时间以后的指定毫秒数，即1970年1月1日00:00:00 GMT。</p>
<p>方法或者类已弃用【已过时】</p>
<p>这一类的方法或者类都是不建议再使用了，但是不是不能用。</p>
<p>win10 —  win xp</p>
<h3 id="2-时间的格式化"><a href="#2-时间的格式化" class="headerlink" title="2. 时间的格式化"></a>2. 时间的格式化</h3><h4 id="2-1-为什么需要时间的格式化？"><a href="#2-1-为什么需要时间的格式化？" class="headerlink" title="2.1 为什么需要时间的格式化？"></a>2.1 为什么需要时间的格式化？</h4><p>默认打印时间的格式为：Sat Nov 13 14:19:49 CST 2021  不符合国内的习惯</p>
<p>SimpleDateFormat：时间格式化的类</p>
<p>SimpleDateFormat(String pattern)  使用给定模式 SimpleDateFormat并使用默认的 FORMAT语言环境的默认日期格式符号。</p>
<p>pattern：用户指定的格式   例如国内习惯时间   2021-11-13 14:23:56</p>
<p>yyyy-MM-dd HH:mm:ss</p>
<p>String format(Date date)  将日期格式化成日期&#x2F;时间字符串。</p>
<p>Date parse(String source)  从给定字符串的开始解析文本以生成日期。</p>
<h2 id="四十二、异常"><a href="#四十二、异常" class="headerlink" title="四十二、异常"></a>四十二、异常</h2><p>代码出现不正常的情况</p>
<h3 id="1-异常体系"><a href="#1-异常体系" class="headerlink" title="1. 异常体系"></a>1. 异常体系</h3><p>Object</p>
<p>|–Throwable</p>
<p>|–Error –体系下面的问题，可能都是一些硬件等问题，可能不是通过代码能解决的</p>
<p>例如一段程序需要联网传输数据</p>
<p>|–Exception–体系下面的问题，都是一些参数，调用方式等问题造成</p>
<h3 id="2-宏观说一下java里面的异常"><a href="#2-宏观说一下java里面的异常" class="headerlink" title="2.宏观说一下java里面的异常"></a>2.宏观说一下java里面的异常</h3><p>1.捕获异常</p>
<p>2.抛异常</p>
<p>在我看来不管是哪一种解决方案，都没真正的去处理异常本身的问题</p>
<h5 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1.捕获异常"></a>1.捕获异常</h5><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">//可能产生异常的代码</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(捕获的异常类型 e)&#123;<span class="comment">//e是形式参数</span></span><br><span class="line"> <span class="comment">//该异常捕获之后要做的操作</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(捕获的异常类型 e)&#123;<span class="comment">//e是形式参数</span></span><br><span class="line"> <span class="comment">//该异常捕获之后要做的操作</span></span><br><span class="line"> &#125;<span class="keyword">finally</span>&#123;<span class="comment">//视情况而定</span></span><br><span class="line"> <span class="comment">//异常发生之后一定会执行到的语句块：①流资源关闭②释放锁</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p>如果try 里面的代码 出现了错误，就立即执行catch里面代码</p>
<p>如果try 里面的代码没有错误，就不执行catch里面的代码</p>
<p>finally里面的代码 无论try里面代码有没有发生异常都要去执行 finally里面的代码</p>
<h5 id="2-catch：里面的异常处理方案"><a href="#2-catch：里面的异常处理方案" class="headerlink" title="2. catch：里面的异常处理方案"></a>2. catch：里面的异常处理方案</h5><p>1.记录日志——方便后期排错–log4j</p>
<p>2.打印异常信息（前期多是这种方案）e.printStackTrace();</p>
<p>3.获取错误信息–可以做额外处理</p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>捕获异常有什么效果：对于可能发生异常代码做捕获的处理，在后期运行的如果发生异常不会因为异常而导致整个程序停止运行</p>
<h4 id="4-异常的处理方案2"><a href="#4-异常的处理方案2" class="headerlink" title="4. 异常的处理方案2"></a>4. 异常的处理方案2</h4><p>抛异常：不处理异常</p>
<p>语法：</p>
<p>在方法的后面加关键字throws 抛出的异常类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名字() <span class="keyword">throws</span> 异常类型<span class="number">1</span>,异常类型<span class="number">2</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-抛异常的执行特点"><a href="#4-1-抛异常的执行特点" class="headerlink" title="4.1 抛异常的执行特点"></a>4.1 抛异常的执行特点</h5><p>一旦发生异常后面的代码就停止执行</p>
<p>java里面的异常类是非常多的，其实大多数的异常类里面的都没有额外逻辑</p>
<p>java里面之所以定义很多异常类主要的目的就是为了进行错误的分类</p>
<p>例如：ArithmeticException：算术异常–一般是因为不符合数学规范造成错误</p>
<p>NullPointerException:空指针异常–一般是因为使用一个空对象去调用方法出现的错误</p>
<p>ArrayIndexOutOfBoundsException:索引越界–一般是因为数组的角标超出索引范围</p>
<p>ClassCastException:类型转换异常–一般是因为类型不一致之间的转换造成</p>
<h5 id="4-2-为什么需要自定义异常"><a href="#4-2-为什么需要自定义异常" class="headerlink" title="4.2 为什么需要自定义异常"></a>4.2 为什么需要自定义异常</h5><p>我们可以自己去扩展，异常的类型来符合功能业务的需要</p>
<h2 id="四十三、创建启动线程方法一"><a href="#四十三、创建启动线程方法一" class="headerlink" title="四十三、创建启动线程方法一"></a>四十三、创建启动线程方法一</h2><p>创建并启动线程的方式一</p>
<p>继承Thread类</p>
<p>public class Thread extends Object implements Runnable</p>
<p>1.写一个类继承Thread</p>
<p>2.覆写run方法</p>
<p>3.创建类的实例【对象】，并且调用start()方法</p>
<p>常用方法：</p>
<p>void start()  导致此线程开始执行;</p>
<p>Java虚拟机调用此线程的run方法。</p>
<p>【这个方法会开启一个新的线程并且调用run()方法】</p>
<p>注意点：</p>
<p>启动线程是调用的start()方法</p>
<h3 id="1-下面的代码有几个线程？"><a href="#1-下面的代码有几个线程？" class="headerlink" title="1.下面的代码有几个线程？"></a>1.下面的代码有几个线程？</h3><p>答：3个线程</p>
<p>main–主线程–开启两个新的线程</p>
<p>musicThread.start();</p>
<p>gameThread.start();</p>
<h3 id="2-如果我调用的是-run-和start-有什么区别"><a href="#2-如果我调用的是-run-和start-有什么区别" class="headerlink" title="2.如果我调用的是 run() 和start()有什么区别?"></a>2.如果我调用的是 run() 和start()有什么区别?</h3><p>答：调用run方法 仅仅只是在主线程，对象调用方法，不会开启新的线程</p>
<p>start()，开启一个新的线程，准备就绪去尝试分配CPU资源，由JVM去调用里面的run方法执行逻辑</p>
<p>1.每一个线程都应该做不同的事情</p>
<p>2.官方在定义这个run方法时候能不能去决定用户的业务逻辑–不能</p>
<p>3.覆写这个run方法主要的目的就是让用户自己去定义自己的逻辑</p>
<h3 id="3-Thread里面常用的一写方法的汇总"><a href="#3-Thread里面常用的一写方法的汇总" class="headerlink" title="3. Thread里面常用的一写方法的汇总"></a>3. Thread里面常用的一写方法的汇总</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>  <span class="comment">//返回对当前正在执行的线程对象的引用。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span>  <span class="comment">//返回此线程的名称</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>  <span class="comment">//将此线程的名称更改为等于参数 name 。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>  <span class="comment">//线程休眠</span></span><br></pre></td></tr></table></figure>



<h2 id="四十四、创建并启动线程方法二"><a href="#四十四、创建并启动线程方法二" class="headerlink" title="四十四、创建并启动线程方法二"></a>四十四、创建并启动线程方法二</h2><p>实现Runnable接口【掌握】</p>
<p>1.自己去新建一个类，实现Runnable接口</p>
<p>2.实现接口里面的run 方法 自己去定义线程的业务逻辑</p>
<p>3.创建一个Runnable实现类的对象，作为一个Thread对象的参数</p>
<p>4.调用start方法启动线程</p>
<h2 id="四十五、解决线程安全问题"><a href="#四十五、解决线程安全问题" class="headerlink" title="四十五、解决线程安全问题"></a>四十五、解决线程安全问题</h2><h3 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1. 同步方法"></a>1. 同步方法</h3><p>1.把可能发生线程安全问题的代码抽取成一个方法</p>
<p>2.在方法上面添加一个synchronized</p>
<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2. 同步代码块"></a>2. 同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (控制同步资源) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>控制同步资源—–&gt;WindowThread.class —&gt;Class实例（唯一性） 在Jvm里面只有一份</p>
<h3 id="3-解决线程安全问题"><a href="#3-解决线程安全问题" class="headerlink" title="3. 解决线程安全问题"></a>3. 解决线程安全问题</h3><p>同步锁-Lock –接口</p>
<p>1.有一把锁</p>
<p>2.上锁</p>
<ol start="3">
<li>做里面逻辑</li>
</ol>
<p>4.释放锁</p>
<p>Lock –接口—创建对象</p>
<p>–实现类	ReentrantLock</p>
<p>常用方法：</p>
<p>void lock()  获得锁。  【上锁】</p>
<p>void unlock() 释放锁。</p>
<h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><p>锁为共享锁，必须要加static</p>
<p>在使用阻塞等待获取锁的方式中,必须在try代码块之外，并且在加锁方法与try代码块之间没有任何可能抛出异常的方法调用，，避免加锁成功后，在finally中无法解锁。</p>
<h2 id="四十六、定时器"><a href="#四十六、定时器" class="headerlink" title="四十六、定时器"></a>四十六、定时器</h2><h3 id="1-创建一个定时任务"><a href="#1-创建一个定时任务" class="headerlink" title="1. 创建一个定时任务"></a>1. 创建一个定时任务</h3><p>1.时间</p>
<p>2.任务</p>
<p>Timer【java.util】</p>
<p>线程调度任务以供将来在后台线程中执行的功能。 任务可以安排一次执行，或定期重复执行。</p>
<h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h3><p>Timer()  创建一个新的计时器。</p>
<h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>  <span class="comment">//终止此计时器，丢弃任何当前计划的任务。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, Date time)</span>  <span class="comment">//在指定的时间安排指定的任务执行。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="type">long</span> period)</span>  <span class="comment">//从指定 的时间开始 ，对指定的任务执行重复的 固定延迟执行 。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay)</span>  <span class="comment">//在指定的延迟之后安排指定的任务执行。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay, <span class="type">long</span> period)</span>  <span class="comment">//在指定 的延迟之后开始 ，重新执行 固定延迟执行的指定任务。</span></span><br></pre></td></tr></table></figure>

<p>time:未来执行的时间点</p>
<p>System.currentTimeMillis() 当前的时间</p>
<p>System.currentTimeMillis()+1000*10 在当前时间上面+10秒钟</p>
<p>new Date(System.currentTimeMillis()+1000*10)  创建一个延后10秒钟的时间Date对象</p>
<h3 id="4-JDK官方能不能提前帮用户统一的定义好定时任务的逻辑-？"><a href="#4-JDK官方能不能提前帮用户统一的定义好定时任务的逻辑-？" class="headerlink" title="4. JDK官方能不能提前帮用户统一的定义好定时任务的逻辑 ？"></a>4. JDK官方能不能提前帮用户统一的定义好定时任务的逻辑 ？</h3><p>这任务具体的逻辑需要用户自己去写，官方来讲 顶多只能定义好标准【接口，抽象类】</p>
<p>断定TimerTask 不是接口 就是抽象类</p>
<p>task：任务</p>
<h2 id="四十七、数据装填的方式"><a href="#四十七、数据装填的方式" class="headerlink" title="四十七、数据装填的方式"></a>四十七、数据装填的方式</h2><p>1.变量—只能放指定类型的一个数据  booolean b&#x3D; true;</p>
<p>2.数组—能够放指定类型 多个数据</p>
<p>2.1  数组也有类型的约束  int[]  String[]</p>
<p>2.2  数组的长度一旦申明以后 长度就不能够改变了  new int[10];</p>
<h2 id="四十八、ArrayList"><a href="#四十八、ArrayList" class="headerlink" title="四十八、ArrayList"></a>四十八、ArrayList</h2><p>能够存储任意类型，任意长度的容器</p>
<h3 id="1-底层原理"><a href="#1-底层原理" class="headerlink" title="1. 底层原理"></a>1. 底层原理</h3><p>1.底层可以定义一个数组来存储数据  Object[]</p>
<p>2.添加数据方法【如果发现容量不够的时候，可以自动扩容】</p>
<p>3.提供一个获取数据方法【根据索引去获取】</p>
<p>4.返回存储了多少个数据的方法</p>
<p>5.删除数据的方法</p>
<h3 id="2-ArrayList里面的常用方法"><a href="#2-ArrayList里面的常用方法" class="headerlink" title="2.ArrayList里面的常用方法"></a>2.ArrayList里面的常用方法</h3><h4 id="1-使用频率高的"><a href="#1-使用频率高的" class="headerlink" title="1.使用频率高的"></a>1.使用频率高的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>  <span class="comment">//将指定的元素添加到此列表的尾部。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 返回此列表中指定位置上的元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>  <span class="comment">// 移除此列表中指定位置上的元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>   <span class="comment">//返回此列表中的元素数。</span></span><br></pre></td></tr></table></figure>



<h4 id="2-偶尔用一下"><a href="#2-偶尔用一下" class="headerlink" title="2.偶尔用一下"></a>2.偶尔用一下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> <span class="comment">//将指定的元素插入此列表中的指定位置。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>    <span class="comment">//移除此列表中的所有元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray()  <span class="comment">//按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。</span></span><br></pre></td></tr></table></figure>

<h2 id="四十九、集合的遍历"><a href="#四十九、集合的遍历" class="headerlink" title="四十九、集合的遍历"></a>四十九、集合的遍历</h2><p>把集合里面的所有的数据取出来</p>
<h3 id="1-普通for循环"><a href="#1-普通for循环" class="headerlink" title="1.普通for循环"></a>1.普通for循环</h3><p>Object get(int index); 获取指定索引位置的值</p>
<p>int size(); 返回集合的长度</p>
<h3 id="2-增强for循环"><a href="#2-增强for循环" class="headerlink" title="2.增强for循环"></a>2.增强for循环</h3><h3 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h3><h4 id="3-1-获取迭代器"><a href="#3-1-获取迭代器" class="headerlink" title="3.1 获取迭代器"></a>3.1 获取迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator <span class="title function_">iterator</span><span class="params">()</span>   <span class="comment">//返回一个在一组 T 类型的元素上进行迭代的迭代器</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-循环"><a href="#3-2-循环" class="headerlink" title="3.2 循环"></a>3.2 循环</h4><p>Iterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>  <span class="comment">//如果仍有元素可以迭代，则返回 true。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">next</span><span class="params">()</span>   <span class="comment">//返回迭代的下一个元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>  <span class="comment">//移除一个元素</span></span><br></pre></td></tr></table></figure>

<p>一个list里面 现有数据[“AA”,”BB”,”CC”,”DD”,”EE”,”FF”,”GG”]</p>
<p>for(int i&#x3D;0;i&lt;list.size();i++){</p>
<p>list.remove(i)</p>
<p>}</p>
<p>答：还剩BB DD FF</p>
<p>原理为动态变化，当第一次删除时删除AA，还剩BB CC DD EE FF GG</p>
<p>当第二次删除时删下标为1的值也就是CC,还剩BB DD EE FF GG</p>
<p>当第三次删除下标为2的值也就是EE,还剩BB DD FF GG</p>
<p>当第四次删除下标为3的值也就是GG,还剩BB DD FF</p>
<p>i&#x3D;3时结束循环</p>
<p>第一次环：i &#x3D;0  [“BB”,”CC”,”DD”,”EE”,”FF”,”GG”]    i&#x3D;1  size&#x3D;6</p>
<p>第二次循环：i &#x3D;1  [“BB”,”DD”,”EE”,”FF”,”GG”] i&#x3D;2  size&#x3D;5</p>
<p>第三次循环：i &#x3D;2  [“BB”,”DD”,”FF”,”GG”] i&#x3D;3 size&#x3D;4</p>
<p>第四次循环：i &#x3D;3  [“BB”,”DD”,”FF”] i&#x3D;4 size&#x3D;3   判断为false 结束循环</p>
<p>请问以上代码 for循环几次 ，删除哪些数据，剩余哪些数据？</p>
<h3 id="重点：移除数据以后-list的size是会动态变化"><a href="#重点：移除数据以后-list的size是会动态变化" class="headerlink" title="重点：移除数据以后 list的size是会动态变化"></a>重点：移除数据以后 list的size是会动态变化</h3><p>for(int i&#x3D;0;i&lt;list.size();i++){</p>
<p>list.remove(i)</p>
<p>}</p>
<h2 id="五十、List（接口）"><a href="#五十、List（接口）" class="headerlink" title="五十、List（接口）"></a>五十、List（接口）</h2><p>ArrayList         LinkedList</p>
<p>都是集合容器</p>
<p>1.如何创建一个容器</p>
<p>2.如何添加数据</p>
<p>3.如何获取数据</p>
<p>4.遍历数据</p>
<p>5.移除数据</p>
<h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><p>LinkedList()  构造一个空列表。</p>
<h4 id="1-1-常用的方法【必须掌握】"><a href="#1-1-常用的方法【必须掌握】" class="headerlink" title="1.1 常用的方法【必须掌握】"></a>1.1 常用的方法【必须掌握】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>   <span class="comment">//将指定元素添加到此列表的结尾。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>    <span class="comment">//返回此列表中指定位置处的元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">//移除此列表中指定位置处的元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>   <span class="comment">//返回此列表中的元素数。</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-了解的方法【有印象】"><a href="#1-2-了解的方法【有印象】" class="headerlink" title="1.2 了解的方法【有印象】"></a>1.2 了解的方法【有印象】</h3><p>针对链表的结构 提供了很多操作头和尾的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>   <span class="comment">// 将指定元素插入此列表的开头。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>  <span class="comment">//返回此列表的第一个元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>  <span class="comment">// 返回此列表的最后一个元素。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-以后在工作中使用LinkedList还是ArrayList"><a href="#2-以后在工作中使用LinkedList还是ArrayList" class="headerlink" title="2. 以后在工作中使用LinkedList还是ArrayList?"></a>2. 以后在工作中使用LinkedList还是ArrayList?</h3><p>LinkedList:删除数据，添加数据速度较快</p>
<p>ArrayList:查询速度较快。</p>
<h2 id="五十二、Set"><a href="#五十二、Set" class="headerlink" title="五十二、Set"></a>五十二、Set</h2><p>(无序【添加顺序】不可重复的容器)</p>
<p>|–HashSet</p>
<p>|–TreeSet</p>
<h3 id="–HashSet"><a href="#–HashSet" class="headerlink" title="|–HashSet"></a>|–HashSet</h3><h4 id="1-如何创建容器HashSet"><a href="#1-如何创建容器HashSet" class="headerlink" title="1.如何创建容器HashSet"></a>1.如何创建容器HashSet</h4><p>构造方法</p>
<p>HashSet()   构造一个新的空 set</p>
<h4 id="2-维护数据的方法"><a href="#2-维护数据的方法" class="headerlink" title="2.维护数据的方法"></a>2.维护数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>  <span class="comment">//如果 set 中尚未存在指定的元素，则添加此元素（可选操作）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>     <span class="comment">//移除此 set 中的所有元素（可选操作）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>   <span class="comment">// 如果 set 中存在指定的元素，则将其移除（可选操作）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>   <span class="comment">// 返回在此 set 中的元素上进行迭代的迭代器。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>  <span class="comment">//返回 set 中的元素数（其容量）。</span></span><br></pre></td></tr></table></figure>

<p>|–HashSet –不允许放入重复的数据，</p>
<h4 id="3-HashSet判断重复的标准"><a href="#3-HashSet判断重复的标准" class="headerlink" title="3. HashSet判断重复的标准"></a>3. HashSet判断重复的标准</h4><p>1.先判断元素的hashCode 是否一致</p>
<p>2.在hashCode相等情况下。继续通过equals方法来判断两个数据是否相等</p>
<p>如果hashCode相等和equals的结果为true 就认为是同一个值</p>
<p>Hash–本身也是一套算法，如果说存储的数据特别多，有可能值不同，hashcode值是一致</p>
<p>HashSet 基于HashMap实现，底层也是键值对，hash值一致  数组+链表+红黑树去实现的（1.8）</p>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><ol>
<li>在存储数据的时候，调用的hashCode的方法 </li>
<li>如果不同，就是两个不同的对象，就存储数据</li>
<li>如果相同，调用equals方法来把存储的数据和容器里面的数据比较</li>
<li>返回是false【数据不一致】  就存储数据</li>
<li>返回的是 true【存储的数据已经重复】 就不存储数据</li>
</ol>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>如果一个类的对象要放到HashSet里面，覆写hashCode 和equals 方法	</p>
<h3 id="–TreeSet"><a href="#–TreeSet" class="headerlink" title="|–TreeSet"></a>|–TreeSet</h3><p>里面放的数据类型要一直，内部需要排序</p>
<h4 id="1-构造方法-1"><a href="#1-构造方法-1" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h4><p>TreeSet()   构造一个新的空 set</p>
<h4 id="2-维护数据的方法-1"><a href="#2-维护数据的方法-1" class="headerlink" title="2. 维护数据的方法"></a>2. 维护数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>  <span class="comment">//如果 set 中尚未存在指定的元素，则添加此元素（可选操作）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>   <span class="comment">// 移除此 set 中的所有元素（可选操作）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>   <span class="comment">// 如果 set 中存在指定的元素，则将其移除（可选操作）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>   <span class="comment">// 返回在此 set 中的元素上进行迭代的迭代器。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>  <span class="comment">//返回 set 中的元素数（其容量）。</span></span><br></pre></td></tr></table></figure>



<h3 id="3-自然排序"><a href="#3-自然排序" class="headerlink" title="3. 自然排序"></a>3. 自然排序</h3><p>放到TreeSet里面的数据类型必须实现Comparable接口，并覆写里面的方法 public int compareTo(T o);</p>
<p>Comparable</p>
<p>|–int compareTo(T o)</p>
<p>0: 代表是重复的元素</p>
<p>正整数： 升序</p>
<p>负整数：降序</p>
<h3 id="4-如果身份证要排序，怎么排？"><a href="#4-如果身份证要排序，怎么排？" class="headerlink" title="4. 如果身份证要排序，怎么排？"></a>4. 如果身份证要排序，怎么排？</h3><p>定制排序：</p>
<p>一个人 ： 名字  年龄   手机号  地区</p>
<p>不同的人 有不同的理解</p>
<p>1.根据年龄排序  年龄小的排前面  年龄大 后面</p>
<p>2.名字，姓氏的首字符排序</p>
<p>3.地区,地区的首字符</p>
<h2 id="五十三、Map"><a href="#五十三、Map" class="headerlink" title="五十三、Map"></a>五十三、Map</h2><p>Map是一个全新的结构,和Collection没有半毛钱关系</p>
<p>将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p>
<p>map存储数据的时候 键值对的形式</p>
<p>key不允许重复</p>
<p>一个key只能定义一个值</p>
<h3 id="1-Map–接口"><a href="#1-Map–接口" class="headerlink" title="1. Map–接口"></a>1. Map–接口</h3><p>|–HashMap</p>
<h4 id="1-1-构造方法-1"><a href="#1-1-构造方法-1" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h4><p>HashMap()   构造一个具有默认初始容量 (16)</p>
<h4 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span>  <span class="comment">//将指定的值与此映射中的指定键关联（可选操作）。 将添加和修改合为一体</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>  <span class="comment">//返回此映射中的键-值映射关系数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>  <span class="comment">//从此映射中移除所有映射关系</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">get</span><span class="params">(Object key)</span> <span class="comment">//根据key 获取值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>  <span class="comment">//如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-遍历方式"><a href="#1-3-遍历方式" class="headerlink" title="1.3 遍历方式"></a>1.3 遍历方式</h3><h4 id="遍历的方式一"><a href="#遍历的方式一" class="headerlink" title="遍历的方式一"></a>遍历的方式一</h4><p>把map里面所有的key取出来  返回一个Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>   <span class="comment">//返回此映射中包含的键的 Set 视图。</span></span><br></pre></td></tr></table></figure>



<h4 id="遍历的方式二"><a href="#遍历的方式二" class="headerlink" title="遍历的方式二"></a>遍历的方式二</h4><p>把map里面所有的Value取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>   <span class="comment">//返回此映射中包含的值Collection 视图</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历的方式三"><a href="#遍历的方式三" class="headerlink" title="遍历的方式三"></a>遍历的方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()   <span class="comment">//返回此映射中包含的映射关系的 Set 视图。</span></span><br></pre></td></tr></table></figure>

<h2 id="五十四、TreeSet"><a href="#五十四、TreeSet" class="headerlink" title="五十四、TreeSet"></a>五十四、TreeSet</h2><p>构造一个新的空 set，该 set 根据其元素的自然顺序进行排序。</p>
<p>TreeSet(Comparator comparator)  构造一个新的空 TreeSet，它根据指定比较器进行排序。</p>
<p>TreeSet:存储数据</p>
<h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><p>类必须实现Comparable接口</p>
<h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>1.针对要存储的数据单独写一个比较类【排序的规则】，实现接口Comparator</p>
<p>2.覆写方法compare，编写比较的逻辑</p>
<p>3.在创建容器对象的时候传入比较类的对象</p>
<h2 id="五十五、泛型"><a href="#五十五、泛型" class="headerlink" title="五十五、泛型"></a>五十五、泛型</h2><p>作用：泛型就是一种约束，例如集合里面的数据，只能放指定类型</p>
<p>在定义的时候不去指定具体的类型，在使用的时候由使用者自己去指定类型</p>
<h3 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1. 注意事项"></a>1. 注意事项</h3><p>1.泛型如果不加，类型就是Object</p>
<p>2.泛型不支持基本数据类型</p>
<p>Point<T> 就是一个泛型类</p>
<p>T由用户在使用的时候去指定T的类型</p>
<h3 id="2-定义泛型的规范"><a href="#2-定义泛型的规范" class="headerlink" title="2. 定义泛型的规范"></a>2. 定义泛型的规范</h3><p>T(Type):类型</p>
<p>E(Element):元素</p>
<p>K(Key):键</p>
<p>V(Value)：值</p>
<p>如果用double：领导找到你 说 double不精确</p>
<p>–把类型改String</p>
<p>String:操作起来可能有些不方便  要转换</p>
<p>–要不还是用double</p>
<h3 id="3-多个团队合作"><a href="#3-多个团队合作" class="headerlink" title="3. 多个团队合作"></a>3. 多个团队合作</h3><p>A团队：String要好用一点，准确</p>
<p>B团队：double要好用一些，操作起来方便 不用转换</p>
<h2 id="五十六、Properties"><a href="#五十六、Properties" class="headerlink" title="五十六、Properties"></a>五十六、Properties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">load</span><span class="params">(InputStream inStream)</span>  <span class="comment">//从输入流中读取属性列表（键和元素对）。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">list</span><span class="params">(PrintStream out)</span>  <span class="comment">//将属性列表输出到指定的输出流。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getProperty</span><span class="params">(String key)</span>  <span class="comment">//用指定的键在此属性列表中搜索属性。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">setProperty</span><span class="params">(String key, String value)</span>   <span class="comment">//调用 Hashtable 的方法 put。</span></span><br></pre></td></tr></table></figure>

<h2 id="五十七、collection与map的简易关系图"><a href="#五十七、collection与map的简易关系图" class="headerlink" title="五十七、collection与map的简易关系图"></a>五十七、collection与map的简易关系图</h2><p>Collection</p>
<p>–List：以特定顺序存储</p>
<p>–ArrayList、LinkList、Vector</p>
<p>–Set：不能包含重复的元素</p>
<p>–HashSet、TreeSet</p>
<p>Map</p>
<p>–HashMap、HashTable、TreeMap</p>
<h2 id="五十八、ArrayList-LinkedList-HashSet-TreeSet-HashMap关系图"><a href="#五十八、ArrayList-LinkedList-HashSet-TreeSet-HashMap关系图" class="headerlink" title="五十八、ArrayList LinkedList  HashSet  TreeSet   HashMap关系图"></a>五十八、ArrayList LinkedList  HashSet  TreeSet   HashMap关系图</h2><table>
<thead>
<tr>
<th></th>
<th>添加的方法</th>
<th>获取值方法</th>
<th>移除的方法</th>
<th>遍历的方式</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>add()</td>
<td>get()</td>
<td>remove()</td>
<td>for、foreach、 Iterator</td>
</tr>
<tr>
<td>LinkedList</td>
<td>add()</td>
<td>get()</td>
<td>remove()</td>
<td>for、foreach、 Iterator</td>
</tr>
<tr>
<td>HashSet</td>
<td>add()</td>
<td>contains()</td>
<td>remove()</td>
<td>foreach、 Iterator</td>
</tr>
<tr>
<td>TreeSet</td>
<td>add()</td>
<td>无</td>
<td>无</td>
<td>foreach、 Iterator</td>
</tr>
<tr>
<td>HashMap</td>
<td>put()</td>
<td>get()</td>
<td>remove()</td>
<td>foreach、 Iterator</td>
</tr>
</tbody></table>
<h2 id="五十九、File"><a href="#五十九、File" class="headerlink" title="五十九、File"></a>五十九、File</h2><p>1.文件</p>
<p>2.文件夹</p>
<p>在Java里面一个File对象就是表示一个文件夹 或者 文件</p>
<h3 id="1-构造方法-2"><a href="#1-构造方法-2" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><p>File(String pathname)  通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。<br> File(String parent, String child)   根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</p>
<p>File(File parent, String child)  根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</p>
<p>File这个类，既可以表示文件，又可以表示文件夹</p>
<h3 id="2-File里面的一些常用方法"><a href="#2-File里面的一些常用方法" class="headerlink" title="2. File里面的一些常用方法"></a>2. File里面的一些常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>  <span class="comment">//创建文件   注意：不能创建文件夹</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>   <span class="comment">//删除此抽象路径名表示的文件或目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：只能去删除文件或者空文件夹</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>  <span class="comment">//测试此抽象路径名表示的文件或目录是否存在。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span>  <span class="comment">//返回由此抽象路径名表示的文件或目录的名称。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getParent</span><span class="params">()</span>  <span class="comment">//返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File <span class="title function_">getParentFile</span><span class="params">()</span>    <span class="comment">//返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>   <span class="comment">//测试此抽象路径名表示的文件是否是一个目录。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>     <span class="comment">//测试此抽象路径名表示的文件是否是一个标准文件。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>  <span class="comment">// 创建此抽象路径名指定的目录。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>  <span class="comment">//创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意：没有权限是不能操作的</p>
<h3 id="3-File里面关于列表的一些方法"><a href="#3-File里面关于列表的一些方法" class="headerlink" title="3. File里面关于列表的一些方法"></a>3. File里面关于列表的一些方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> File[] listRoots() <span class="comment">//列出可用的文件系统根。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] list()  <span class="comment">//返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File[] listFiles()  <span class="comment">//返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</span></span><br></pre></td></tr></table></figure>

<h3 id="4-什么是递归调用"><a href="#4-什么是递归调用" class="headerlink" title="4. 什么是递归调用"></a>4. 什么是递归调用</h3><p>简单的理解在一个方法的内部自己调用自己</p>
<p>方法的递归调用的注意事项：</p>
<p>递归必须要有出口，如果没有出口最终只有一个结果 栈内存溢出 StackOverflowError</p>
<h2 id="六十、斐波拉契数列"><a href="#六十、斐波拉契数列" class="headerlink" title="六十、斐波拉契数列"></a>六十、斐波拉契数列</h2><h2 id="1-已知条件"><a href="#1-已知条件" class="headerlink" title="1. 已知条件"></a>1. 已知条件</h2><p>f(0)&#x3D;0   f(1)&#x3D;1</p>
<p>已知有个公式 f(n)&#x3D;f(n-1)+f(n-2) 前提条件 n&gt;&#x3D;2</p>
<p>f(2)&#x3D;f(1)+f(0) 	&#x3D;1</p>
<p>f(3)&#x3D;f(2)+f(1) 	&#x3D;2</p>
<p>f(4)&#x3D;f(3)+f(2) 	&#x3D;3</p>
<p>f(5)&#x3D;f(4)+f(3) 	&#x3D;5</p>
<p>f(6)&#x3D;f(5)+f(4) 	&#x3D;8</p>
<p>使用程序算 f(5) 等于多少？</p>
<h2 id="2-对于递归调用"><a href="#2-对于递归调用" class="headerlink" title="2.  对于递归调用"></a>2.  对于递归调用</h2><p>1.知道是怎么一回事就可以了</p>
<p>2.递归的次数越多，效率越低</p>
<p>3.理解这种思想就够了，后面其实很少用到</p>
<p>4.哪些地方要使用递归，有层级关系，菜单栏</p>
<h2 id="六十一、字节流"><a href="#六十一、字节流" class="headerlink" title="六十一、字节流"></a>六十一、字节流</h2><h3 id="1-字节输入流"><a href="#1-字节输入流" class="headerlink" title="1. 字节输入流"></a>1. 字节输入流</h3><p>1.每次读取的单位是一个字节</p>
<p>2.写程序去文件里面读取数据【把文件里面的数据取出来】</p>
<p>InputStream：字节输入流的所有类的父类</p>
<p>抽象类：不能直接创建对象【不能new】，如果要创建对象，找InputStream的子类</p>
<p>FileInputStream：用于读取诸如图像数据之类的原始字节流</p>
<h4 id="1-1-构造方法-2"><a href="#1-1-构造方法-2" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h4><p>FileInputStream(File file) 就是去读取一个指定的文件</p>
<p>FileInputStream(String name) 读取一个指定文件【传入文件的路径】</p>
<h4 id="1-2-常识"><a href="#1-2-常识" class="headerlink" title="1.2 常识"></a>1.2 常识</h4><p>1.一个字母占一个字节</p>
<p>2.一个中文占两个字节【GBK】</p>
<h4 id="1-3-读取数据的方法"><a href="#1-3-读取数据的方法" class="headerlink" title="1.3 读取数据的方法"></a>1.3 读取数据的方法</h4><p>大多数读取的数据方法都叫-read</p>
<p>int read()  从此输入流中读取一个数据字节。 返回字母的ASCII ,如果已到达文件末尾，则返回 -1。</p>
<h3 id="2-字节输出流"><a href="#2-字节输出流" class="headerlink" title="2. 字节输出流"></a>2. 字节输出流</h3><p>1.输出的单位 字节</p>
<p>2.输出流，把数据写到文件里面去</p>
<p>OutputStream：抽象类</p>
<h4 id="2-1-FileOutputStream"><a href="#2-1-FileOutputStream" class="headerlink" title="2.1 FileOutputStream"></a>2.1 FileOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(File file)   <span class="comment">//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(File file, <span class="type">boolean</span> append)  <span class="comment">//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name)  <span class="comment">//创建一个向具有指定名称的文件中写入数据的输出文件流。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name, <span class="type">boolean</span> append)   <span class="comment">//创建一个向具有指定 name 的文件中写入数据的输出文件流。</span></span><br></pre></td></tr></table></figure>

<p> append：如果为true 就是追加内容<br> append：如果是false 或者不写  就是覆盖内容</p>
<h4 id="2-2-输出内容的方法"><a href="#2-2-输出内容的方法" class="headerlink" title="2.2 输出内容的方法"></a>2.2 输出内容的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>  <span class="comment">//将指定字节写入此文件输出流。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>   <span class="comment">//将 b.length 个字节从指定 byte 数组写入此文件输出流中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>  <span class="comment">//将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</span></span><br></pre></td></tr></table></figure>

<p>off：从b这个数组里面第几个位置开始写出数据</p>
<p>len：写几个数据出去</p>
<h4 id="2-3-写出中文"><a href="#2-3-写出中文" class="headerlink" title="2.3 写出中文"></a>2.3 写出中文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>   <span class="comment">//将 b.length 个字节从指定 byte 数组写入此文件输出流中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>  <span class="comment">//将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</span></span><br></pre></td></tr></table></figure>

<p>off：从b这个数组里面第几个位置开始写出数据</p>
<p>len：写几个数据出去</p>
<p>中文</p>
<p>gbk:占2个字节</p>
<p>UTF-8:占3个字节</p>
<h3 id="3-字节流特点"><a href="#3-字节流特点" class="headerlink" title="3. 字节流特点"></a>3. 字节流特点</h3><p>1.不适合读取中文，如果说一段数据 边读取边查看<br>2.多用于去读取视频，音频，图片等二进制文件【不适合去读取一些文字类的文件 txt doc】</p>
<h2 id="六十二、字符流"><a href="#六十二、字符流" class="headerlink" title="六十二、字符流"></a>六十二、字符流</h2><h3 id="1-字符输入流"><a href="#1-字符输入流" class="headerlink" title="1. 字符输入流"></a>1. 字符输入流</h3><p>Reader:用于读取字符流的抽象类</p>
<p>FileReader:</p>
<h4 id="1-1-构造方法-3"><a href="#1-1-构造方法-3" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader(String fileName)   <span class="comment">//在给定从中读取数据的文件名的情况下创建一个新 FileReader。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader(File file)  <span class="comment">//在给定从中读取数据的 File 的情况下创建一个新 FileReader。</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-读取数据"><a href="#1-2-读取数据" class="headerlink" title="1.2 读取数据"></a>1.2 读取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>   <span class="comment">//读取单个字符。  如果达到文件末尾 返回-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span>  <span class="comment">//将字符读入数组。</span></span><br></pre></td></tr></table></figure>

<p>BufferReader 这个类里面有一个方法叫做readLine() 可以一次性读取一行数据</p>
<p>要求：大家立即查看api文档，学习这个类  读取一个java文件在控制台打印内容。</p>
<h3 id="2-字符输出流"><a href="#2-字符输出流" class="headerlink" title="2. 字符输出流"></a>2. 字符输出流</h3><p>Writer：-抽象类</p>
<h4 id="2-1-构造方法-1"><a href="#2-1-构造方法-1" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file)   <span class="comment">//根据给定的 File 对象构造一个 FileWriter 对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file, <span class="type">boolean</span> append)  <span class="comment">//根据给定的 File 对象构造一个 FileWriter 对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(String fileName)   <span class="comment">//根据给定的文件名构造一个 FileWriter 对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(String fileName, <span class="type">boolean</span> append)   <span class="comment">//根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。</span></span><br></pre></td></tr></table></figure>



<h3 id="3-字符流特点"><a href="#3-字符流特点" class="headerlink" title="3. 字符流特点"></a>3. 字符流特点</h3><p>一般适合去操作文本文件</p>
<h2 id="六十三、字节输入流-—-字符输入流"><a href="#六十三、字节输入流-—-字符输入流" class="headerlink" title="六十三、字节输入流 —-字符输入流"></a>六十三、字节输入流 —-字符输入流</h2><p>InputStreamReader</p>
<p>InputStreamReader(InputStream in)  创建一个使用默认字符集的 InputStreamReader。</p>
<h2 id="六十四、把字节输出流—字符输出流"><a href="#六十四、把字节输出流—字符输出流" class="headerlink" title="六十四、把字节输出流—字符输出流"></a>六十四、把字节输出流—字符输出流</h2><p>OutputStreamWriter</p>
<p>OutputStreamWriter(OutputStream out)   创建使用默认字符编码的 OutputStreamWriter。</p>
<h2 id="六十五、自动关流"><a href="#六十五、自动关流" class="headerlink" title="六十五、自动关流"></a>六十五、自动关流</h2><p> java 1.7以后针对这种关闭流资源比较臃肿的情况提供了一种新的结构</p>
<p>需要自动关闭的流资源-必须实现AutoCloseable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要自动关闭的流资源)&#123;</span><br><span class="line"></span><br><span class="line">可能发生异常的代码块</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">捕获异常之后要做的处理</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六十六、-接口的默认方法"><a href="#六十六、-接口的默认方法" class="headerlink" title="六十六、 接口的默认方法"></a>六十六、 接口的默认方法</h2><h3 id="1-1-传统的方法（之前的）"><a href="#1-1-传统的方法（之前的）" class="headerlink" title="1.1. 传统的方法（之前的）"></a>1.1. 传统的方法（之前的）</h3><p>在Java8之前Java中接口里面的方法默认都是public abstract 修饰的抽象方法并且没有方法体；</p>
<h3 id="1-2-static方法"><a href="#1-2-static方法" class="headerlink" title="1.2. static方法"></a>1.2. static方法</h3><p>1、使用static修饰接口中的方法并且必须有主体；</p>
<p>2、接口的static方法只能够被接口本身调用；接口名.方法名（…）；</p>
<p>3、接口的static方法不能够被子接口继承；</p>
<p>4、接口的static方法不能够被实现类覆写及直接调用；</p>
<h3 id="1-3-default方法"><a href="#1-3-default方法" class="headerlink" title="1.3. default方法"></a>1.3. default方法</h3><p>在接口中可定义一个使用default修饰有方法体的方法，接口中可以对这个方法提供默认的一种实现。</p>
<p>1、使用default修饰接口中的方法并且必须有主体；</p>
<p>2、接口的default方法不能够被接口本身调用，需要接口的实例（实现类对象）来调用；</p>
<p>3、接口的default方法可以被子接口继承、覆写或者直接调用；</p>
<p>4、接口的default方法可以被实现类覆写及直接调用；</p>
<p>在接口中,经过static和default修饰的方法必须有方法体;</p>
<p>static修饰的方法调用方式为类.方法名</p>
<p>default修饰的方法必须是实现类的对象调用</p>
<p>static修饰的方法不能被子接口继承,default修饰的方法可以被子接口继承</p>
<p>并复写方法,就可以创建子接口实现类对象进行调用</p>
<h2 id="六十七、接口里面可以有哪些内容"><a href="#六十七、接口里面可以有哪些内容" class="headerlink" title="六十七、接口里面可以有哪些内容"></a>六十七、接口里面可以有哪些内容</h2><p>抽象方法</p>
<p>成员变量</p>
<h3 id="1-jdk8以后"><a href="#1-jdk8以后" class="headerlink" title="1. jdk8以后"></a>1. jdk8以后</h3><p>静态方法 — 静态方法如何去调用  类名.方法名()</p>
<p>默认方法 — 默认方法如何使用  实现类对象.方法名()</p>
<p>在Java8以后新增了一个注解</p>
<h3 id="1-2函数式接口"><a href="#1-2函数式接口" class="headerlink" title="1.2函数式接口"></a>1.2函数式接口</h3><p>就是一种要求，把只有一个抽象方法的接口叫做函数式接口【静态方法和默认方法个数无关】</p>
<p>回顾一下：我们以前学过的接口里面 哪些有以上特征【函数式接口】</p>
<p>Runnable</p>
<p>Comparator:定制排序</p>
<p>@FunctionalInterface:可以去验证一接口是否是函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基本语法：</span><br><span class="line">	&lt;函数式接口&gt;  &lt;变量名&gt; = (参数<span class="number">1</span>，参数<span class="number">2.</span>..) -&gt; &#123;</span><br><span class="line">                  <span class="comment">//方法体</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>  (参数1，参数2…)表示参数列表；-&gt;表示连接符；{}内部是方法体<br>    1、&#x3D;右边的类型会根据左边的函数式接口类型自动推断；<br>    2、如果形参列表为空，只需保留()；<br>    3、如果形参只有1个，()可以省略，只需要参数的名称即可；<br>    4、如果执行语句只有1句，且无返回值，{}可以省略，若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有1句；<br>    5、形参列表的数据类型会自动推断；<br>    6、lambda不会生成一个单独的内部类文件；<br>    7、lambda表达式若访问了局部变量，则局部变量必须是final的，若是局部变量没有加final关键字，系统会自动添加，此后在修改该局部变量，会报错</p>
<h2 id="六十八、Lambda表达式"><a href="#六十八、Lambda表达式" class="headerlink" title="六十八、Lambda表达式"></a>六十八、Lambda表达式</h2><p>Lambda：主要是针对匿名内部类简写优化【借鉴了前端的语法】</p>
<p>Lambda表达式只能对函数式接口进行书写	</p>
<p>lambda表达式不会产生字节码文件</p>
<p> java8以后，更推荐链式编程</p>
<p>Stream:就是针对数据进行一些连续的操作</p>
<h2 id="六十九、数据库的数据"><a href="#六十九、数据库的数据" class="headerlink" title="六十九、数据库的数据"></a>六十九、数据库的数据</h2><p>1.筛选</p>
<p>2.排序</p>
<p>3.分组</p>
<p>4.分页	</p>
<h2 id="七十、-Stream流"><a href="#七十、-Stream流" class="headerlink" title="七十、 Stream流"></a>七十、 Stream流</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ol>
<li><p>&lt;strong元素队列&lt; strong&#x3D;””&gt;元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。&lt;&#x2F;strong元素队列&lt;&gt;</p>
</li>
<li><p>数据源 流的来源。 可以是集合，数组，I&#x2F;O channel（nio new IO非阻塞式IO）， 产生器generator 等。</p>
</li>
<li><p>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</p>
</li>
</ol>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ol start="4">
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>. 内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ol>
<h3 id="1-1-生成流"><a href="#1-1-生成流" class="headerlink" title="1.1. 生成流"></a>1.1. 生成流</h3><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<p>stream() − 为集合创建串行流。</p>
<p>parallelStream() − 为集合创建并行流。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://dclef.icu">老猫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dclef.icu/2021/11/01/%E5%BF%AB%E9%80%9F%E5%AD%A6%E5%AE%8CJAVA%E5%9F%BA%E7%A1%80/">https://dclef.icu/2021/11/01/快速学完JAVA基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dclef.icu" target="_blank">老猫的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javase/">javase</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/java.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dclef/CDN/img/wepay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/dclef/CDN/img/wepay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dclef/CDN/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/dclef/CDN/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/21/Mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/PHP.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mysql的一些常用方法</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/HEXO.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hexo博客主题搭建</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NzMxOC8zMzc4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/dclef/CDN/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">老猫</div><div class="author-info__description">小白教程</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dclef"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dclef" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:drclef233@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://dclef.icu/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">兄弟们就看看嗷！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B3%A8%E9%87%8A"><span class="toc-number">1.</span> <span class="toc-text">一、注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.标识符定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">二、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">1.数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%95%B4%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B0%8F%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 小数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%AD%97%E7%AC%A6"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 布尔型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 String(字符串)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.引用数据类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">3. 变量的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">三、数据的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">1.自动转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.</span> <span class="toc-text">2.强制转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">四、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.</span> <span class="toc-text">1.数学运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 加减乘除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 赋值运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 比较运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.4.</span> <span class="toc-text">1.4 三目运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">5.</span> <span class="toc-text">五、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">5.1.</span> <span class="toc-text">1.逻辑运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">六、选择结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-if-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.1.</span> <span class="toc-text">1.if 条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%AF%AD%E6%B3%95%E4%B8%80"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1 语法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AF%AD%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BA%92%E6%96%A5"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2 语法二：互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%AF%AD%E6%B3%95%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">6.1.3.</span> <span class="toc-text">1.3 语法三：多条件判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-switch-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.2.</span> <span class="toc-text">2.switch 循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-default"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-break"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.2 break</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-while%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.3.</span> <span class="toc-text">3.while循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-dowhile%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.4.</span> <span class="toc-text">4.dowhile循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-For%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.5.</span> <span class="toc-text">5.For循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.6.</span> <span class="toc-text">6.循环控制语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%87%E5%87%86"><span class="toc-number">7.</span> <span class="toc-text">七、学习数组的标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84-%E8%AF%AD%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">1.如何定义一个数组(语法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%AF%AD%E6%B3%95%E4%B8%80-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1 语法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AF%AD%E6%B3%95%E4%BA%8C"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2 语法二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%96%E5%80%BC%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">2.数组的取值与赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%B5%8B%E5%80%BC%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1 赋值的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8F%96%E5%80%BC%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2 取值的语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F"><span class="toc-number">7.3.</span> <span class="toc-text">3.注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">八、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">1.方法如何定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">2.方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1  方法名()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%B1%BB%E5%90%8D-%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 类名.方法名()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%AF%B9%E8%B1%A1%E5%90%8D-%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">8.2.3.</span> <span class="toc-text">2.3 对象名.方法名()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E5%94%AF%E4%B8%80%E5%85%A5%E5%8F%A3"><span class="toc-number">8.3.</span> <span class="toc-text">程序运行的唯一入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BD%A2%E5%8F%82"><span class="toc-number">8.4.</span> <span class="toc-text">3.形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.5.</span> <span class="toc-text">4.返回值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-void"><span class="toc-number">8.5.1.</span> <span class="toc-text">4.1 void</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89%EF%BC%9A"><span class="toc-number">8.5.2.</span> <span class="toc-text">4.2数据类型（学习过的所有数据类型）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%83%E7%94%A8%E8%80%85%E5%AF%B9%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">5.调用者对于方法的返回值有哪些处理方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%9B%B4%E6%8E%A5%E6%89%93%E5%8D%B0"><span class="toc-number">8.6.1.</span> <span class="toc-text">5.1   直接打印</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E6%8E%A5%E6%94%B6"><span class="toc-number">8.6.2.</span> <span class="toc-text">5.2  使用变量接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">8.7.</span> <span class="toc-text">方法的重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">九、数组的存储模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%BD"><span class="toc-number">9.1.</span> <span class="toc-text">1.1 栽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A0%86"><span class="toc-number">9.2.</span> <span class="toc-text">1.2 堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99"><span class="toc-number">10.</span> <span class="toc-text">十、方法调用的时候</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">十一、可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81for%E2%80%94each-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">12.</span> <span class="toc-text">十二、for—each  增强for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81javadoc"><span class="toc-number">13.</span> <span class="toc-text">十三、javadoc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">十四、构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">1.什么是构造方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.2.</span> <span class="toc-text">1.2构造方法的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">14.3.</span> <span class="toc-text">1.3构造方法的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E9%97%AE%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">1.4问构造方法和方法有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.</span> <span class="toc-text">十五、匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">16.</span> <span class="toc-text">十六、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">1.可以继承哪些内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%97%E5%93%AA%E4%BA%9B%E5%9B%A0%E6%95%B0%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">16.2.</span> <span class="toc-text">2. 受哪些因数影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">16.3.</span> <span class="toc-text">3. 继承的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E6%96%B9%E6%B3%95%E8%A6%86%E5%86%99-Override"><span class="toc-number">17.</span> <span class="toc-text">十七、方法覆写-Override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E5%86%99%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">1. 什么情况下需要方法的覆写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A6%81%E6%B1%82"><span class="toc-number">17.2.</span> <span class="toc-text">2. 要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B"><span class="toc-number">17.2.1.</span> <span class="toc-text">2.1 一般情况下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%B4%E4%BD%93%E5%A4%A7%E7%BA%B2"><span class="toc-number">17.2.2.</span> <span class="toc-text">2.2 方法调用的整体大纲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81super"><span class="toc-number">18.</span> <span class="toc-text">十八、super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-number">18.1.</span> <span class="toc-text">1. 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9"><span class="toc-number">18.2.</span> <span class="toc-text">2. 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-super%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.3.</span> <span class="toc-text">3. super和this的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">19.</span> <span class="toc-text">十九、抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%88%90%E5%91%98"><span class="toc-number">19.1.</span> <span class="toc-text">1.1 抽象类里面有哪些成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">19.2.</span> <span class="toc-text">1.2 抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%9B%AE%E5%89%8D%E8%BF%99%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">19.3.</span> <span class="toc-text">1.3 目前这个知识点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.</span> <span class="toc-text">二十、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">20.1.</span> <span class="toc-text">1. 接口的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8E%E9%9D%A2%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%93%E7%8E%B0"><span class="toc-number">20.2.</span> <span class="toc-text">2.后面这些功能体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">20.3.</span> <span class="toc-text">3.接口的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9C%A8jdk%E7%9A%841-8%E4%BB%A5%E5%90%8E%E6%96%B0%E5%A2%9E%E5%BE%88%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.4.</span> <span class="toc-text">4. 在jdk的1.8以后新增很多新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E8%A6%86%E5%86%99%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">21.</span> <span class="toc-text">二十一、覆写的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E5%86%99%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">21.1.</span> <span class="toc-text">方法覆写的调用规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81Object"><span class="toc-number">22.</span> <span class="toc-text">二十二、Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-final-finally-finalize-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">22.1.</span> <span class="toc-text">1. final finally finalize -区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%A8%E8%AE%BA"><span class="toc-number">22.2.</span> <span class="toc-text">2. 讨论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%9D%E8%80%83%EF%BC%9A%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">22.3.</span> <span class="toc-text">3. 思考：面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">23.</span> <span class="toc-text">二十三、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BE%8B%E5%AD%90"><span class="toc-number">23.1.</span> <span class="toc-text">1. 例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%98%E6%96%B9"><span class="toc-number">23.2.</span> <span class="toc-text">2. 官方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9D%8A%E9%97%B4"><span class="toc-number">23.3.</span> <span class="toc-text">3. 坊间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Super%E2%80%93%E7%88%B6%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="toc-number">23.4.</span> <span class="toc-text">Super–父类相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81final"><span class="toc-number">24.</span> <span class="toc-text">二十四、final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E5%86%85%E5%AE%B9"><span class="toc-number">24.1.</span> <span class="toc-text">1. 可以修饰内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0%E4%BB%A5%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E6%95%88%E6%9E%9C"><span class="toc-number">24.2.</span> <span class="toc-text">2. 被final修饰以后有什么效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81static"><span class="toc-number">25.</span> <span class="toc-text">二十五、static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static%EF%BC%9A%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">25.1.</span> <span class="toc-text">1. static：修饰的成员正确的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">25.2.</span> <span class="toc-text">1.1 修饰成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">25.3.</span> <span class="toc-text">1.2 方法的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-static%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E7%9A%84%E7%A7%B0%E5%91%BC"><span class="toc-number">25.4.</span> <span class="toc-text">2. static修饰的成员的称呼</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">26.</span> <span class="toc-text">二十六、匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%A3%E5%B8%B8%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">26.1.</span> <span class="toc-text">1. 正常的顺序:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">26.2.</span> <span class="toc-text">2. 匿名内部类使用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">27.</span> <span class="toc-text">二十七、代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">27.1.</span> <span class="toc-text">1. 构造代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">27.2.</span> <span class="toc-text">2. 静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B1%80%E9%83%A8%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">27.3.</span> <span class="toc-text">3. 局部代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">28.</span> <span class="toc-text">二十八、面对对象整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%EF%BC%9A%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81"><span class="toc-number">28.1.</span> <span class="toc-text">核心内容：封装-继承-多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3"><span class="toc-number">28.1.1.</span> <span class="toc-text">1. 封装思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E6%80%9D%E6%83%B3"><span class="toc-number">28.1.2.</span> <span class="toc-text">2. 继承思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">28.1.2.1.</span> <span class="toc-text">2.1 继承的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">28.1.2.2.</span> <span class="toc-text">2.2 继承之后的效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">28.1.2.3.</span> <span class="toc-text">2.3 继承的优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E6%80%9D%E6%83%B3"><span class="toc-number">28.1.3.</span> <span class="toc-text">3. 多态思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">29.</span> <span class="toc-text">二十九、包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">29.1.</span> <span class="toc-text">1.什么是包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8F%90%E4%BE%9B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">29.2.</span> <span class="toc-text">2.为什么要提供包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="toc-number">29.3.</span> <span class="toc-text">3.包装类和基本数据类型有哪些不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1"><span class="toc-number">29.3.1.</span> <span class="toc-text">3.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2"><span class="toc-number">29.3.2.</span> <span class="toc-text">3.2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">30.</span> <span class="toc-text">三十、包装类装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%80%E3%80%81String"><span class="toc-number">31.</span> <span class="toc-text">三十一、String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%BA%8C%E3%80%81String-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">32.</span> <span class="toc-text">三十二、String 的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%89%E3%80%81-x3D-x3D-%E5%92%8C-equals%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">三十三、&#x3D;&#x3D; 和 equals区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AD%E3%80%81String%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">34.</span> <span class="toc-text">三十六、String常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%83%E3%80%81String-StringBuilder-StringBuffer-%E9%83%BD%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">35.</span> <span class="toc-text">三十七、String StringBuilder StringBuffer 都是字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">35.1.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AB%E3%80%81Math"><span class="toc-number">36.</span> <span class="toc-text">三十八、Math</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5-PI"><span class="toc-number">36.1.</span> <span class="toc-text">1. 字段  PI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BigDecimal%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">36.2.</span> <span class="toc-text">2. BigDecimal【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">36.2.1.</span> <span class="toc-text">2.1 构造方法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-BigDecimal%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E8%A1%8C%E4%B8%9A%E5%92%8C%E9%A2%86%E5%9F%9F%EF%BC%9F"><span class="toc-number">36.2.2.</span> <span class="toc-text">2.2 BigDecimal一般用于哪些行业和领域？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B9%9D%E3%80%81java%E9%87%8C%E9%9D%A2%E9%9A%8F%E6%9C%BA%E6%95%B0%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">37.</span> <span class="toc-text">三十九、java里面随机数获取方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Math"><span class="toc-number">37.1.</span> <span class="toc-text">1. Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Random"><span class="toc-number">37.2.</span> <span class="toc-text">2. Random</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E3%80%81System"><span class="toc-number">38.</span> <span class="toc-text">四十、System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Runtime"><span class="toc-number">38.1.</span> <span class="toc-text">1. Runtime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B8%80%E3%80%81%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">39.</span> <span class="toc-text">四十一、和时间相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java-util-Date-%E5%AD%A6%E4%B9%A0"><span class="toc-number">39.1.</span> <span class="toc-text">1. java.util.Date[学习]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">39.1.1.</span> <span class="toc-text">1.1 构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%B6%E9%97%B4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">39.2.</span> <span class="toc-text">2. 时间的格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%B6%E9%97%B4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%9F"><span class="toc-number">39.2.1.</span> <span class="toc-text">2.1 为什么需要时间的格式化？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%BA%8C%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-number">40.</span> <span class="toc-text">四十二、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">40.1.</span> <span class="toc-text">1. 异常体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8F%E8%A7%82%E8%AF%B4%E4%B8%80%E4%B8%8Bjava%E9%87%8C%E9%9D%A2%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">40.2.</span> <span class="toc-text">2.宏观说一下java里面的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">40.2.0.1.</span> <span class="toc-text">1.捕获异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-catch%EF%BC%9A%E9%87%8C%E9%9D%A2%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-number">40.2.0.2.</span> <span class="toc-text">2. catch：里面的异常处理方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">40.2.1.</span> <span class="toc-text">3. 总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%882"><span class="toc-number">40.2.2.</span> <span class="toc-text">4. 异常的处理方案2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="toc-number">40.2.2.1.</span> <span class="toc-text">4.1 抛异常的执行特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">40.2.2.2.</span> <span class="toc-text">4.2 为什么需要自定义异常</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">41.</span> <span class="toc-text">四十三、创建启动线程方法一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%89%E5%87%A0%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">41.1.</span> <span class="toc-text">1.下面的代码有几个线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E6%88%91%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF-run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">41.2.</span> <span class="toc-text">2.如果我调用的是 run() 和start()有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Thread%E9%87%8C%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E6%B1%87%E6%80%BB"><span class="toc-number">41.3.</span> <span class="toc-text">3. Thread里面常用的一写方法的汇总</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E5%9B%9B%E3%80%81%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">42.</span> <span class="toc-text">四十四、创建并启动线程方法二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%BA%94%E3%80%81%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">43.</span> <span class="toc-text">四十五、解决线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">43.1.</span> <span class="toc-text">1. 同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">43.2.</span> <span class="toc-text">2. 同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">43.3.</span> <span class="toc-text">3. 解决线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F"><span class="toc-number">43.4.</span> <span class="toc-text">4. 注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E5%85%AD%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">44.</span> <span class="toc-text">四十六、定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">44.1.</span> <span class="toc-text">1. 创建一个定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">44.2.</span> <span class="toc-text">2. 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">44.3.</span> <span class="toc-text">3. 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JDK%E5%AE%98%E6%96%B9%E8%83%BD%E4%B8%8D%E8%83%BD%E6%8F%90%E5%89%8D%E5%B8%AE%E7%94%A8%E6%88%B7%E7%BB%9F%E4%B8%80%E7%9A%84%E5%AE%9A%E4%B9%89%E5%A5%BD%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%BB%E8%BE%91-%EF%BC%9F"><span class="toc-number">44.4.</span> <span class="toc-text">4. JDK官方能不能提前帮用户统一的定义好定时任务的逻辑 ？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E8%A3%85%E5%A1%AB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">45.</span> <span class="toc-text">四十七、数据装填的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E5%85%AB%E3%80%81ArrayList"><span class="toc-number">46.</span> <span class="toc-text">四十八、ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">46.1.</span> <span class="toc-text">1. 底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ArrayList%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">46.2.</span> <span class="toc-text">2.ArrayList里面的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87%E9%AB%98%E7%9A%84"><span class="toc-number">46.2.1.</span> <span class="toc-text">1.使用频率高的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%81%B6%E5%B0%94%E7%94%A8%E4%B8%80%E4%B8%8B"><span class="toc-number">46.2.2.</span> <span class="toc-text">2.偶尔用一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B9%9D%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">47.</span> <span class="toc-text">四十九、集合的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF"><span class="toc-number">47.1.</span> <span class="toc-text">1.普通for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">47.2.</span> <span class="toc-text">2.增强for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">47.3.</span> <span class="toc-text">3.迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">47.3.1.</span> <span class="toc-text">3.1 获取迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BE%AA%E7%8E%AF"><span class="toc-number">47.3.2.</span> <span class="toc-text">3.2 循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E7%A7%BB%E9%99%A4%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%90%8E-list%E7%9A%84size%E6%98%AF%E4%BC%9A%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">47.4.</span> <span class="toc-text">重点：移除数据以后 list的size是会动态变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E3%80%81List%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">48.</span> <span class="toc-text">五十、List（接口）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">48.1.</span> <span class="toc-text">1. 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%90%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="toc-number">48.1.1.</span> <span class="toc-text">1.1 常用的方法【必须掌握】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BA%86%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%90%E6%9C%89%E5%8D%B0%E8%B1%A1%E3%80%91"><span class="toc-number">48.2.</span> <span class="toc-text">1.2 了解的方法【有印象】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A5%E5%90%8E%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%BF%E7%94%A8LinkedList%E8%BF%98%E6%98%AFArrayList"><span class="toc-number">48.3.</span> <span class="toc-text">2. 以后在工作中使用LinkedList还是ArrayList?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%BA%8C%E3%80%81Set"><span class="toc-number">49.</span> <span class="toc-text">五十二、Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93HashSet"><span class="toc-number">49.1.</span> <span class="toc-text">|–HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8HashSet"><span class="toc-number">49.1.1.</span> <span class="toc-text">1.如何创建容器HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%B4%E6%8A%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">49.1.2.</span> <span class="toc-text">2.维护数据的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HashSet%E5%88%A4%E6%96%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%A0%87%E5%87%86"><span class="toc-number">49.1.3.</span> <span class="toc-text">3. HashSet判断重复的标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">49.1.4.</span> <span class="toc-text">判断方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">49.1.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93TreeSet"><span class="toc-number">49.2.</span> <span class="toc-text">|–TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">49.2.1.</span> <span class="toc-text">1. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%B4%E6%8A%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95-1"><span class="toc-number">49.2.2.</span> <span class="toc-text">2. 维护数据的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">49.3.</span> <span class="toc-text">3. 自然排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%A6%81%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%EF%BC%9F"><span class="toc-number">49.4.</span> <span class="toc-text">4. 如果身份证要排序，怎么排？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B8%89%E3%80%81Map"><span class="toc-number">50.</span> <span class="toc-text">五十三、Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Map%E2%80%93%E6%8E%A5%E5%8F%A3"><span class="toc-number">50.1.</span> <span class="toc-text">1. Map–接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">50.1.1.</span> <span class="toc-text">1.1 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">50.1.2.</span> <span class="toc-text">1.2 常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">50.2.</span> <span class="toc-text">1.3 遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">50.2.1.</span> <span class="toc-text">遍历的方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">50.2.2.</span> <span class="toc-text">遍历的方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-number">50.2.3.</span> <span class="toc-text">遍历的方式三</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E5%9B%9B%E3%80%81TreeSet"><span class="toc-number">51.</span> <span class="toc-text">五十四、TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">51.1.</span> <span class="toc-text">自然排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">51.2.</span> <span class="toc-text">定制排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">52.</span> <span class="toc-text">五十五、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">52.1.</span> <span class="toc-text">1. 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-number">52.2.</span> <span class="toc-text">2. 定义泛型的规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E4%B8%AA%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C"><span class="toc-number">52.3.</span> <span class="toc-text">3. 多个团队合作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E5%85%AD%E3%80%81Properties"><span class="toc-number">53.</span> <span class="toc-text">五十六、Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B8%83%E3%80%81collection%E4%B8%8Emap%E7%9A%84%E7%AE%80%E6%98%93%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">54.</span> <span class="toc-text">五十七、collection与map的简易关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E5%85%AB%E3%80%81ArrayList-LinkedList-HashSet-TreeSet-HashMap%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">55.</span> <span class="toc-text">五十八、ArrayList LinkedList  HashSet  TreeSet   HashMap关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B9%9D%E3%80%81File"><span class="toc-number">56.</span> <span class="toc-text">五十九、File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">56.1.</span> <span class="toc-text">1. 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-File%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">56.2.</span> <span class="toc-text">2. File里面的一些常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-File%E9%87%8C%E9%9D%A2%E5%85%B3%E4%BA%8E%E5%88%97%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">56.3.</span> <span class="toc-text">3. File里面关于列表的一些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">56.4.</span> <span class="toc-text">4. 什么是递归调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E3%80%81%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">57.</span> <span class="toc-text">六十、斐波拉契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%B2%E7%9F%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">58.</span> <span class="toc-text">1. 已知条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">59.</span> <span class="toc-text">2.  对于递归调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E4%B8%80%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">60.</span> <span class="toc-text">六十一、字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">60.1.</span> <span class="toc-text">1. 字节输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">60.1.1.</span> <span class="toc-text">1.1 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B8%B8%E8%AF%86"><span class="toc-number">60.1.2.</span> <span class="toc-text">1.2 常识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">60.1.3.</span> <span class="toc-text">1.3 读取数据的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">60.2.</span> <span class="toc-text">2. 字节输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-FileOutputStream"><span class="toc-number">60.2.1.</span> <span class="toc-text">2.1 FileOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">60.2.2.</span> <span class="toc-text">2.2 输出内容的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%86%99%E5%87%BA%E4%B8%AD%E6%96%87"><span class="toc-number">60.2.3.</span> <span class="toc-text">2.3 写出中文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E8%8A%82%E6%B5%81%E7%89%B9%E7%82%B9"><span class="toc-number">60.3.</span> <span class="toc-text">3. 字节流特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">61.</span> <span class="toc-text">六十二、字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">61.1.</span> <span class="toc-text">1. 字符输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">61.1.1.</span> <span class="toc-text">1.1 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">61.1.2.</span> <span class="toc-text">1.2 读取数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">61.2.</span> <span class="toc-text">2. 字符输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">61.2.1.</span> <span class="toc-text">2.1 构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%89%B9%E7%82%B9"><span class="toc-number">61.3.</span> <span class="toc-text">3. 字符流特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E4%B8%89%E3%80%81%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81-%E2%80%94-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">62.</span> <span class="toc-text">六十三、字节输入流 —-字符输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E5%9B%9B%E3%80%81%E6%8A%8A%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E2%80%94%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">63.</span> <span class="toc-text">六十四、把字节输出流—字符输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%85%B3%E6%B5%81"><span class="toc-number">64.</span> <span class="toc-text">六十五、自动关流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E5%85%AD%E3%80%81-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">65.</span> <span class="toc-text">六十六、 接口的默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%B9%8B%E5%89%8D%E7%9A%84%EF%BC%89"><span class="toc-number">65.1.</span> <span class="toc-text">1.1. 传统的方法（之前的）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-static%E6%96%B9%E6%B3%95"><span class="toc-number">65.2.</span> <span class="toc-text">1.2. static方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-default%E6%96%B9%E6%B3%95"><span class="toc-number">65.3.</span> <span class="toc-text">1.3. default方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E4%B8%83%E3%80%81%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="toc-number">66.</span> <span class="toc-text">六十七、接口里面可以有哪些内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-jdk8%E4%BB%A5%E5%90%8E"><span class="toc-number">66.1.</span> <span class="toc-text">1. jdk8以后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">66.2.</span> <span class="toc-text">1.2函数式接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E5%85%AB%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">67.</span> <span class="toc-text">六十八、Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">68.</span> <span class="toc-text">六十九、数据库的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%8D%81%E3%80%81-Stream%E6%B5%81"><span class="toc-number">69.</span> <span class="toc-text">七十、 Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%94%9F%E6%88%90%E6%B5%81"><span class="toc-number">69.1.</span> <span class="toc-text">1.1. 生成流</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/24/%E5%9C%A8butterfly%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0rss%E8%AE%A2%E9%98%85/" title="在butterfly主题中添加rss订阅"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/HEXO.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在butterfly主题中添加rss订阅"/></a><div class="content"><a class="title" href="/2022/09/24/%E5%9C%A8butterfly%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0rss%E8%AE%A2%E9%98%85/" title="在butterfly主题中添加rss订阅">在butterfly主题中添加rss订阅</a><time datetime="2022-09-24T04:48:08.009Z" title="发表于 2022-09-24 12:48:08">2022-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6go(%E4%B8%80)/" title="从零开始学go（一）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/dclef/CDN/go/go-logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从零开始学go（一）"/></a><div class="content"><a class="title" href="/2022/09/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6go(%E4%B8%80)/" title="从零开始学go（一）">从零开始学go（一）</a><time datetime="2022-09-22T13:00:00.000Z" title="发表于 2022-09-22 21:00:00">2022-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/Spring-SpringMVC/" title="Spring和SpringMVC的常用注解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/2021822.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring和SpringMVC的常用注解"/></a><div class="content"><a class="title" href="/2022/01/21/Spring-SpringMVC/" title="Spring和SpringMVC的常用注解">Spring和SpringMVC的常用注解</a><time datetime="2022-01-21T01:00:00.000Z" title="发表于 2022-01-21 09:00:00">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/OSI%E6%A8%A1%E5%9E%8B/" title="OSI模型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/VPN.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OSI模型"/></a><div class="content"><a class="title" href="/2021/12/11/OSI%E6%A8%A1%E5%9E%8B/" title="OSI模型">OSI模型</a><time datetime="2021-12-11T01:00:00.000Z" title="发表于 2021-12-11 09:00:00">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6springboot(%E4%B8%80)/" title="从零开始学springboot（一）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Dclef/CDN/img/2021822.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从零开始学springboot（一）"/></a><div class="content"><a class="title" href="/2021/12/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6springboot(%E4%B8%80)/" title="从零开始学springboot（一）">从零开始学springboot（一）</a><time datetime="2021-12-11T01:00:00.000Z" title="发表于 2021-12-11 09:00:00">2021-12-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 老猫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'AcXrsvmCNVcPqWbExlSsvPjl-gzGzoHsz# leancloud application app id',
      appKey: 'bFM3KX5ofIw2bgLTraJXvget# leancloud application app key',
      avatar: 'monsterid',
      serverURLs: 'https://acxrsvmc.lc-cn-n1-shared.com# This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = 'JjJmRRwzoQ5ktTyD7';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (false) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>